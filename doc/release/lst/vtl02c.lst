ca65 V2.17 - Git 59ab140
Main file   : ..\src\vtl02c.a65
Current file: ..\src\vtl02c.a65

000000r 1               	.IF PLATFORM > 1
000000r 1               		.include "homebrew.inc"
000000r 2               ;
000000r 2               ; PLATFORM = 0 : Homebrew - FPGA
000000r 2               ; PLATFORM = 1 : Homebrew - Hardware
000000r 2               ; PLATFORM = 2 : Atari XL/XE
000000r 2               ;
000000r 2               IO		= $FFFF00
000000r 2               ROMSTART	= $E000		;$8000 = Test, $E000 = Prod
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Kernel jumptable
000000r 2               ;--------------------------------------------------------------
000000r 2               jkernel		= ROMSTART
000000r 2               jchrin		= ROMSTART + $3
000000r 2               jchrout		= ROMSTART + $6
000000r 2               jprint		= ROMSTART + $9
000000r 2               jprinthex	= ROMSTART + $C
000000r 2               jgetupper	= ROMSTART + $F
000000r 2               jgethex		= ROMSTART + $12
000000r 2               jgetadr		= ROMSTART + $15
000000r 2               jnewline	= ROMSTART + $18
000000r 2               jspace		= ROMSTART + $1B
000000r 2               jhexdownload	= ROMSTART + $1E
000000r 2               jmemdump	= ROMSTART + $21
000000r 2               jinputhex	= ROMSTART + $24
000000r 2               jchangemem	= ROMSTART + $27
000000r 2               jfillmem	= ROMSTART + $2A
000000r 2               jfill		= ROMSTART + $2D
000000r 2               jnmin		= ROMSTART + $30
000000r 2               jirqn		= ROMSTART + $33
000000r 2               jbrk		= ROMSTART + $36
000000r 2               jtime		= ROMSTART + $39
000000r 2               jmenu		= ROMSTART + $3C
000000r 2               jdisass		= ROMSTART + $3F
000000r 2               jdisone		= ROMSTART + $42
000000r 2               jrs232v		= ROMSTART + $45
000000r 2               jsetaddress	= ROMSTART + $48
000000r 2               jmemdump16	= ROMSTART + $4B
000000r 2               jkgbirq		= ROMSTART + $4E	;(4-bytes !!)
000000r 2               jdisass24	= ROMSTART + $52
000000r 2               jcopn		= ROMSTART + $55
000000r 2               
000000r 2               ;
000000r 2               ; Dummy vectors
000000r 2               ;
000000r 2               jcope		= ROMSTART + $30
000000r 2               jaborte		= ROMSTART + $30
000000r 2               jabortn		= ROMSTART + $30
000000r 2               jirqe		= ROMSTART + $30
000000r 2               jnmie		= ROMSTART + $30
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SD CARD constants
000000r 2               ;--------------------------------------------------------------
000000r 2               CMD0		= $40 +  0	;GO_IDLE_STATE	0x40, 64
000000r 2               CMD1		= $40 +  1	;reset
000000r 2               CMD8		= $40 +  8	;SEND_IF_COND	0x48, 72
000000r 2               CMD9		= $40 +  9	;SEND_CSD	0x49, 73
000000r 2               CMD13		= $40 + 13	;get_status	0x4D, 77
000000r 2               CMD17		= $40 + 17	;read  sector 	0x51, 81
000000r 2               CMD24		= $40 + 24	;write sector 	0x58, 88
000000r 2               CMD41		= $40 + 41	;SEND_OP_COND	0x69, 105 (leave idle state)
000000r 2               CMD55		= $40 + 55	;ACMD 		0x77, 119
000000r 2               CMD58		= $40 + 58	;READ_OCR	0x7A, 122
000000r 2               
000000r 2               DATA_START_BLOCK	= $FE
000000r 2               DATA_RES_MASK		= $1F
000000r 2               DATA_RES_ACCEPTED	= $05
000000r 2               
000000r 2               CMD0CHK		= $95
000000r 2               CMD1CHK		= $F9
000000r 2               CMD8CHK		= $87
000000r 2               
000000r 2               R1_IDLE_STATE	= 1
000000r 2               R1_ILLEGAL_COMMAND = 4
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; MISC constants
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               NEGATIVE	= $80
000000r 2               OVERFLOW	= $40		;
000000r 2               M		= $20		; Accu 8/16-bit
000000r 2               IX		= $10		; Index 8/16-bit
000000r 2               DECIMAL_FLAG	= $08		; Decimal Flag
000000r 2               ID		= $04		; IRQ disable
000000r 2               ZERO		= $02		; zero flag
000000r 2               CARRY		= $01		; Carry
000000r 2               
000000r 2               CHARS40		= 40
000000r 2               CHARS80		= 80
000000r 2               NUMROWS		= 25
000000r 2               
000000r 2               ;	special key scan-codes
000000r 2               ALTGR		= $11	;extended!
000000r 2               ALR		= $11
000000r 2               CLSHIFT		= $12
000000r 2               CLSTRG		= $14
000000r 2               CRSHIFT		= $59
000000r 2               CCAPS		= $58
000000r 2               
000000r 2               CCHARLINE	= 80	;80 chars per line
000000r 2               
000000r 2               	.if PLATFORM = 0
000000r 2               SCRSTRT		= $F800
000000r 2               SCRBANK		= $7F
000000r 2               	.else
000000r 2               SCRSTRT		= $C000
000000r 2               	.endif
000000r 2               charset		= $F800
000000r 2               
000000r 2               jusermenu	= $0400
000000r 2               juserkeys	= $0403
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI constants
000000r 2               ;--------------------------------------------------------------
000000r 2               LEDGE	= 	0	;left edge
000000r 2               
000000r 2               MAXDEV	=	33	;offset to last possible entry of HATABS
000000r 2               
000000r 2               IOCBSZ	=	16	;length of IOCB
000000r 2               IOCFRE	=	$FF	;IOCB free indicator
000000r 2               
000000r 2               SEIOCB	=	0*IOCBSZ	;screen editor IOCB index
000000r 2               MAXIOC	=	8*IOCBSZ	;first invalid IOCB index
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Device Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               CASSET	=	'C'	;cassette
000000r 2               DISK	=	'D'	;disk
000000r 2               SCREDT	=	'E'	;screen editor
000000r 2               KBD	=	'K'	;keyboard
000000r 2               PRINTR	=	'P'	;printer
000000r 2               DISPLY	=	'S'	;screen display
000000r 2               RS232D	=	'R'	;RS232 serial interface
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	IOCB Command Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               OPEN	=	$03	;open
000000r 2               GETREC	=	$05	;get record
000000r 2               GETCHR	=	$07	;get character(s) (binary)
000000r 2               PUTREC	=	$09	;put record
000000r 2               PUTCHR	=	$0B	;put character(s)
000000r 2               CLOSE	=	$0C	;close
000000r 2               STATUS	=	$0D	;status
000000r 2               SPECIL	=	$0E	;special
000000r 2               
000000r 2               CXIO36	= 	36
000000r 2               CXIO38	=	38
000000r 2               CXIO40	=	40
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Character and Key Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               			;SUPERF <>  0
000000r 2               
000000r 2               CCHM	=	$1C	;move cursor home
000000r 2               CCBT	=	$1D	;move cursor to bottom
000000r 2               CCLM	=	$1E	;move cursor to left margin
000000r 2               CCRM	=	$1F	;move cursor to right margin
000000r 2               
000000r 2               			;SUPERF = 0
000000r 2               
000000r 2               CLS	=	$01	;clear screen
000000r 2               BACK	=	$08	;backspace
000000r 2               EOL	=	$0A	;$9B	;end of line (RETURN)
000000r 2               ESC	=	$1B	;escape key
000000r 2               CCUP	=	$1C	;cursor up
000000r 2               CCDN	=	$1D	;cursor down
000000r 2               CCLF	=	$1E	;cursor left
000000r 2               CCRT	=	$1F	;cursor right
000000r 2               CSPACE	=	$20	;space
000000r 2               TABU	=	$7F	;tabulator
000000r 2               CILN	=	$9D	;insert line
000000r 2               CDCH	=	$FE	;delete character
000000r 2               CICH	=	$FF	;insert character
000000r 2               
000000r 2               HELP	=	$11	;key code for HELP
000000r 2               CNTLF1	=	$83	;key code for CTRL-F1
000000r 2               CNTLF2	=	$84	;key code for CTRL-F2
000000r 2               CNTLF3	=	$93	;key code for CTRL-F3
000000r 2               CNTLF4	=	$94	;key code for CTRL-F4
000000r 2               CNTL1	=	$9F	;key code for CTRL-1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ;	Status Code equates
000000r 2               ;--------------------------------------------------------------
000000r 2               SUCCES	=	1	;successful operation
000000r 2               
000000r 2               BRKABT	=	128	;BREAK key abort
000000r 2               PRVOPN	=	129	;IOCB already open error
000000r 2               NONDEV	=	130	;nonexistent device error
000000r 2               WRONLY	=	131	;IOCB opened for write only error
000000r 2               NVALID	=	132	;invalid command error
000000r 2               NOTOPN	=	133	;device/file not open error
000000r 2               BADIOC	=	134	;invalid IOCB index error
000000r 2               RDONLY	=	135	;IOCB opened for read only error
000000r 2               EOFERR	=	136	;end of file error
000000r 2               TRNRCD	=	137	;truncated record error
000000r 2               TIMOUT	=	138	;peripheral device timeout error
000000r 2               DNACK	=	139	;device does not acknowledge command error
000000r 2               FRMERR	=	140	;serial bus framing error
000000r 2               CRSROR	=	141	;cursor overrange error
000000r 2               OVRRUN	=	142	;serial bus data overrun error
000000r 2               CHKERR	=	143	;serial bus checksum error
000000r 2               DERROR	=	144	;device done (operation incomplete) error
000000r 2               BADMOD	=	145	;bad screen mode number error
000000r 2               FNCNOT	=	146	;function not implemented in handler error
000000r 2               SCRMEM	=	147	;insufficient memory for screen mode error
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew variables Zero page
000000r 2               ;--------------------------------------------------------------
000000r 2               ptr		= $00	;2-byte misc. pointer
000000r 2               memptr		= $02	;3-byte pointer
000000r 2               
000000r 2               PCREG		= $02   ;3-byte redefine for disassembler
000000r 2               PCREGH		= PCREG+1
000000r 2               PCREGB		= PCREGH+1
000000r 2               
000000r 2               chksum		= $05	;1-byte checksum
000000r 2               
000000r 2               FATPTRS_	= $06	;2-byte FAT source pointer
000000r 2               FATPTRD_	= $08	;2-byte FAT destination pointer
000000r 2               PTRDUP		= $0A	;2-byte misc. pointer DUP
000000r 2               SECPTR		= $0C	;2-byte sector pointer
000000r 2               CHRPTR		= $0E	;2-byte sector pointer hi-res char handling
000000r 2               DEVICNO		= $10	;1-byte stdout device (0=RS232, 1=CRT)
000000r 2               TEMP		= $11	;3-byte pointer for debug16
000000r 2               TEMPH		= $12
000000r 2               TEMPB		= $13
000000r 2               PREG		= $14	;1-byte P STATUS REGISTER
000000r 2               gethex_A	= $15	;1-byte save accu
000000r 2               
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; ATARI zeropage
000000r 2               ;--------------------------------------------------------------
000000r 2               ZIOCB	=	$0020	;address of page zero IOCB
000000r 2               IOCBAS	=	$0020	;16-byte page zero IOCB
000000r 2               ICHIDZ	=	$0020	;1-byte handler ID ($FF = IOCB free)
000000r 2               ICDNOZ	=	$0021	;1-byte device number
000000r 2               ICCOMZ	=	$0022	;1-byte command code
000000r 2               ICSTAZ	=	$0023	;1-byte status of last action
000000r 2               ICBALZ	=	$0024	;1-byte buffer address low
000000r 2               ICBAHZ	=	$0025	;1-byte buffer address high
000000r 2               ICBABZ	=	$0026	;1-byte buffer address bank
000000r 2               ICBLLZ	=	$0027	;1-byte buffer length low
000000r 2               ICBLHZ	=	$0028	;1-byte buffer length high
000000r 2               ICBLBZ	=	$0029	;1-byte buffer length bank
000000r 2               ICAX1Z	=	$002A	;1-byte first auxiliary information
000000r 2               ICAX2Z	=	$002B	;1-byte second auxiliary information
000000r 2               ICSPRZ	=	$002C	;4-byte spares
000000r 2               ;ENTVEC	=	$002C	;2-byte (not used)
000000r 2               ICIDNO	=	$002E	;1-byte IOCB index (IOCB number times IOCBSZ)
000000r 2               CIOCHR	=	$002F	;1-byte character for current CIO operation
000000r 2               ;ICPTLZ	=	$0026	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTHZ	=	$0027	;1-byte high PUT-BYTE routine address-1
000000r 2               
000000r 2               BRKKEY	=	$0030	;1-byte BREAK key flag (0 = no BREAK)
000000r 2               ICCOMT	=	$0031	;1-byte CIO command table index
000000r 2               DSTAT	=	$0032	;1-byte display status
000000r 2               TMPCHR	=	$0033	;1-byte	temporary character
000000r 2               HOLD1	=	$0034	;1-byte	temporary
000000r 2               LMARGN	=	$0035	;1-byte text column left margin
000000r 2               RMARGN	=	$0036	;1-byte text column right margin
000000r 2               ROWCRS	=	$0037	;1-byte cursor row
000000r 2               COLCRS	=	$0038	;2-byte cursor column
000000r 2               ALTACT	=	$003A	;1-byte ALRGR active --display mode
000000r 2               SAVMSC	=	$003B	;2-byte saved memory scan counter
000000r 2               OLDROW	=	$003D	;1-byte prior row
000000r 2               OLDCOL	=	$003E	;2-byte prior column
000000r 2               OLDCHR	=	$0040	;1-byte saved character under cursor
000000r 2               OLDADR	=	$0041	;3-byte saved cursor memory address
000000r 2               
000000r 2               LOGCOL	=	$0044	;1-byte logical line cursor column
000000r 2               
000000r 2               ;DUMMY	=	$0044	;2-byte temporary address
000000r 2               
000000r 2               ;MLTTMP	=	$0046	;1-byte temporary
000000r 2               ;OPNTMP	=	$0046	;1-byte open temporary
000000r 2               TOADR	=	$0045	;3-byte destination address
000000r 2               
000000r 2               SAVADR	=	$0048	;3-byte saved address
000000r 2               FRMADR	=	$0048	;3-byte source address
000000r 2               
000000r 2               RAMTOP	=	$004B	;1-byte RAM size
000000r 2               BUFCNT	=	$004C	;1-byte buffer count (logical line size)
000000r 2               BUFSTR	=	$004D	;2-byte buffer start pointer
000000r 2               BITMSK	=	$004F	;1-byte bit mask for bit map operation
000000r 2               ;SHFAMT	=	$004F	;1-byte shift amount for pixel justification
000000r 2               ROWAC	=	$0050	;2-byte draw working row
000000r 2               COLAC	=	$0052	;2-byte draw working column
000000r 2               ENDPT	=	$0054	;2-byte end point
000000r 2               DELTAR	=	$0056	;1-byte row difference
000000r 2               DELTAC	=	$0057	;2-byte column difference
000000r 2               SWPFLG	=	$0059	;1-byte split screen swap flag (0 = not swapped)
000000r 2               INSDAT	=	$005A	;1-byte temporary
000000r 2               COUNTR	=	$005B	;2-byte draw iteration count
000000r 2               ADRESS	=	$005D	;3-byte temporary address
000000r 2               
000000r 2               
000000r 2               
000000r 2               XREG	= ADRESS+3       ; X REGISTER
000000r 2               XREGH 	= XREG+1
000000r 2               
000000r 2               YREG = XREGH+1         ; Y REGISTER
000000r 2               YREGH = YREG+1
000000r 2               
000000r 2               AREG = YREGH+1         ; ACCUMULATOR
000000r 2               AREGH = AREG+1
000000r 2               
000000r 2               STACK = AREGH+1        ; STACK POINTER
000000r 2               STACKH = STACK+1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 2
000000r 2               ;--------------------------------------------------------------
000000r 2               TXTROW	=	$0200	;1-byte split screen text cursor row
000000r 2               TXTCOL	=	$0201	;2-byte split screen text cursor column
000000r 2               TINDEX	=	$0203	;1-byte split scree text mode
000000r 2               TXTMSC	=	$0204	;2-byte split screen memory scan counter
000000r 2               TXTOLD	=	$0206	;6-byte OLDROW, OLDCOL, OLDCHR, OLDADR for text
000000r 2               HOLD3	=	$020C	;1-byte temporary
000000r 2               SUBTMP	=	$020D	;1-byte temporary
000000r 2               HOLD2	=	$020E	;1-byte (not used)
000000r 2               ;DMASK	=	$020F	;1-byte display (pixel location) mask
000000r 2               ;TMPLBT	=	$0210	;1-byte (not used)
000000r 2               RASVEC	=	$020F	;raster interrupt vector
000000r 2               ESCFLG	=	$0211	;1-byte escape flag ($80 = ESC detected)
000000r 2               TABMAP	=	$0212	;15-byte (120-bit) tab stop bit map
000000r 2               LOGMAP	=	$0221	;8-byte (32-bit) logical line bit map
000000r 2               CLSFLG	=	$0229	;1-byte clear screen flag
000000r 2               FILFLG	=	$022A	;1-byte right fill flag (0 = no fill)
000000r 2               TMPROW	=	$022B	;1-byte temporary row
000000r 2               TMPCOL	=	$022C	;2-byte temporary column
000000r 2               SCRFLG	=	$022E	;1-byte scroll occurence flag (0 = not occurred)
000000r 2               HOLD4	=	$022F	;1-byte temporary
000000r 2               DRETRY	=	$0230	;1-byte number of device retries
000000r 2               SHFLOK	=	$0231	;1-byte shift/control lock flags
000000r 2               BOTSCR	=	$0232	;1-byte screen bottom (24 = normal, 4 = split)
000000r 2               
000000r 2               DVSTAT	=	$0233	;4-byte device status buffer
000000r 2               CRSINH	=	$0237	;1-byte cursor inhibit (0 = cursor on)
000000r 2               DUMMY00	=	$0238	;1-byte key debounce delay timer
000000r 2               CH1	=	$0239	;1-byte prior keyboard character
000000r 2               
000000r 2               NEWROW	=	$023A	;1-byte draw destination row
000000r 2               NEWCOL	=	$023B	;2-byte draw destination column
000000r 2               ROWINC	=	$023D	;1-byte draw row increment
000000r 2               COLINC	=	$023E	;1-byte	draw column increment
000000r 2               
000000r 2               CHAR	=	$023F	;1-byte internal character
000000r 2               ATACHR	=	$0240	;1-byte ATASCII character or plot point
000000r 2               FILDAT	=	$0241	;1-byte right fill data
000000r 2               DSPFLG	=	$0242	;1-byte control character display flag (0 = no)
000000r 2               SSFLAG	=	$0243	;1-byte start/stop flag (0 = not stopped)
000000r 2               
000000r 2               SUPERF	=	$0244	;1-byte editor super function flag :
000000r 2               ;DERRF	=	$0245	;1-byte screen OPEN error flag (0 = not)
000000r 2               
000000r 2               skipone	=	$0246	;1-byte
000000r 2               extended=	$0247	;1-byte
000000r 2               ADRCNT	=	$0248	;1-byte counter for setaddress
000000r 2               
000000r 2               IRQVEC	=	$0249	;2-byte
000000r 2               NMIVEC	=	$024B	;2-byte
000000r 2               jmpind	=	$024D	;1-byte $4C = JMP
000000r 2               jmpptr	=	$024E	;2-byte
000000r 2               DBUFLO	=	$0250	;2-byte ;2-byte adr of 512-byte buffer for SD CARD read/Write
000000r 2               sdcmd	=	$0252	;1-byte SD card command
000000r 2               sdadr	=	$0253	;4-byte SD card address
000000r 2               sdchk	=	$0257	;1-byte SD card checksum
000000r 2               sdres	=	$0258	;1-byte SD card R1 result
000000r 2               sddebug =	$0259	;1-byte SD card debug flag
000000r 2               FVEC	=	$025A	;2-byte executable file start vector
000000r 2               FINIT	=	$025C	;2-byte executable file init vector
000000r 2               JSLOP	=	$025E	;1-byte JSL-opcode
000000r 2               JSLADR	=	$025F	;3-byte JSL address
000000r 2               JSLRTS	=	$0262	;1-byte RTS-opcode
000000r 2               JMLOP	=	$0263	;1-byte JML-opcode
000000r 2               JMLADR	=	$0264	;3-byte JML address
000000r 2               DEVSTAT	=	$0269	;4-byte device status
000000r 2               SERCNT0	= 	$026D	;1-byte RS232 0 control bits
000000r 2               SERCNT1	= 	$026E	;1-byte RS232 1 control bits
000000r 2               CONST5MS=	$026F	;2-byte timer const
000000r 2               ;FSTART	=	$0271	;2-byte file load start vector save
000000r 2               ;FEND	=	$0273	;2-byte file load end vector save
000000r 2               ;FSTARTS	=	$0275	;2-byte file load start vector save
000000r 2               ;FENDS	=	$0277	;2-byte file load end vector save
000000r 2               ;FDIFF	=	$0279	;2-byte into difference save
000000r 2               MONACT	=	$027B	;4-byte break-monitor active flags
000000r 2               
000000r 2               IOCBSTRT=	$0280		;start of IOCB
000000r 2               IOCB	=	IOCBSTRT + $0	;128-byte I/O control blocks area
000000r 2               ICHID	=	IOCBSTRT + $0	;1-byte handler ID ($FF = free)
000000r 2               ICDNO	=	IOCBSTRT + $1	;1-byte device number
000000r 2               ICCOM	=	IOCBSTRT + $2	;1-byte command code
000000r 2               ICSTA	=	IOCBSTRT + $3	;1-byte status of last action
000000r 2               ICBAL	=	IOCBSTRT + $4	;1-byte low buffer address
000000r 2               ICBAH	=	IOCBSTRT + $5	;1-byte high buffer address
000000r 2               ICBAB	=	IOCBSTRT + $6	;1-byte bank buffer address
000000r 2               ICBLL	=	IOCBSTRT + $7	;1-byte low buffer length
000000r 2               ICBLH	=	IOCBSTRT + $8	;1-byte high buffer length
000000r 2               ICBLB	=	IOCBSTRT + $9	;1-byte bank buffer length
000000r 2               ICAX1	=	IOCBSTRT + $A	;1-byte first auxiliary information
000000r 2               ICAX2	=	IOCBSTRT + $B	;1-byte second auxiliary information
000000r 2               ICSPR	=	IOCBSTRT + $C	;4-byte work area
000000r 2               ;ICPTL	=	IOCBSTRT + $6	;1-byte low PUT-BYTE routine address-1
000000r 2               ;ICPTH	=	IOCBSTRT + $7	;1-byte high PUT-BYTE routine address-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 3
000000r 2               ;--------------------------------------------------------------
000000r 2               HATABS	=	$0300	;12 * 3-byte entries for HATABS
000000r 2               ;MONTAB	=	$0324	;8-byte break-monitor pointer
000000r 2               flags	=	$032C	;1-byte processor flags during IRQ
000000r 2               IRQPS2S	=	$032D	;1-byte PS2-status from IRQ
000000r 2               IRQPS2D =	$032E	;1-byte PS2-data from IRQ
000000r 2               DEVICS	=	$032F	;1-byte DEVICENO SAVE
000000r 2               BRKBRA	=	$0330	;1-byte branch opcode
000000r 2               BRKOFF	=	$0331	;1-byte branch offset (always 3)
000000r 2               BRKNOT	=	$0332	;1-byte jmp branch not taken (always $4c)
000000r 2               BRKJMP0	=	$0333	;2-byte jmp address branch not taken
000000r 2               BRKTAK	=	$0335	;1-byte jmp branch taken (always $4c)
000000r 2               BRKJMP1	=	$0336	;2-byte jmp address branch taken
000000r 2               BRKVEC	=	$0338	;2-byte BRK vector (65816)
000000r 2               WARMFLAG=	$033A	;1-byte Warmstart = $CA
000000r 2               ARGC	=	$033B	;2-byte number of args
000000r 2               ARGV	=	$033D	;8*2-bytes pointer to arg strings
000000r 2               NCODE	= 	$034D	;1-byte NEXT CODE TO BE TRACED
000000r 2               OPCREG	=	$034E	;3-byte OLD PROGRAM COUNTER VALUE
000000r 2               OPCREGH	=	$034F
000000r 2               OPCREGB	=	$0350
000000r 2               CODE	=	$0351	;1-byte CURRENT CODE TO BE TRACED
000000r 2               OPRNDL	=	$0352	;3-byte OPERANDS OF CURRENT INSTRUCTION
000000r 2               OPRNDH	=	$0353
000000r 2               OPRNDB	=	$0354
000000r 2               ADDRMODE=	$0355	; ADDRESS MODE OF CURRENT OPCODE
000000r 2               
000000r 2               MNX	=	$0356 	;2-byte MNEMONIC INDEX
000000r 2                                       ; FROM ATTRIBUTE TABLE
000000r 2               OPLEN 	=	$0358   ;1-byte LENGTH OF OPERATION,
000000r 2                                       ; INCLUDING INSTRUCTION
000000r 2               MOVENEG	=	$0359	;4-byte MVP + operands + RTS
000000r 2               MOVEBNK	=	$035A
000000r 2               MOVERTS	=	$035C	;RTS
000000r 2               
000000r 2               MODBASE	=	$035D	;2-byte base for next module to be loaded
000000r 2               
000000r 2               MONTAB	=	$0360	;4*4-byte break-monitor pointer
000000r 2               
000000r 2               COLCNT	=	$0370	;
000000r 2               COPVEC	=	$0371	;2-byte COP vector
000000r 2               NEXTFRE	=	$0373	;
000000r 2               
000000r 2               FNAME	= 	$0380	;128-byte buffer for line
000000r 2               ;--------------------------------------------------------------
000000r 2               ; page 4
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC6845 graphics
000000r 2               ;--------------------------------------------------------------
000000r 2               crtadr		= $B800
000000r 2               crtdata		= $B801
000000r 2               
000000r 2               crtcol0		= $B880
000000r 2               crtcol1		= $B881
000000r 2               crtcol2		= $B882
000000r 2               crtcol3		= $B883
000000r 2               crtcolb		= crtcol3
000000r 2               
000000r 2               crtcntl		= $B8C0
000000r 2               crtirq		= $B8C1
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MOS6551 serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               ;data6551	= $DB00
000000r 2               ;status6551	= $DB01
000000r 2               ;command6551	= $DB02
000000r 2               ;control6551	= $DB03
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew YM2612 registers
000000r 2               ;--------------------------------------------------------------
000000r 2               YMADR0		= $BFB0
000000r 2               YMDAT0		= $BFB1
000000r 2               YMADR1		= $BFB2
000000r 2               YMDAT1		= $BFB3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew	Memory Control
000000r 2               ;--------------------------------------------------------------
000000r 2               MEMCNTL		= $BFC0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew PS2-keyboard and SD-Card
000000r 2               ;--------------------------------------------------------------
000000r 2               PS2		= IO + $D0
000000r 2               PS2DATA		= PS2 + 0	; keyboard scancode
000000r 2               PS2STATUS	= PS2 + 1	; read: Bit0 = 0 scancode available
000000r 2               SPIDATA		= PS2 + 2	; read: Bit0 serial data in, write: Bit7 serial data out
000000r 2               SPIMOSI		= PS2 + 3	; write: Bit0: 1 = Mosi always 1, Bit1: write: CS of SDCard
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew Centronics 8-bit latch
000000r 2               ;--------------------------------------------------------------
000000r 2               CENTRONICS	= $BFE0
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; Homebrew MC68681 double serial card
000000r 2               ;--------------------------------------------------------------
000000r 2               SB		= $BFF0
000000r 2               
000000r 2               MODEA		= 0
000000r 2               STATA		= 1
000000r 2               CLOCKA		= 1
000000r 2               COMMA		= 2
000000r 2               RECA		= 3
000000r 2               TRANSA		= 3
000000r 2               IPCHANGE	= 4
000000r 2               AUXCTRL		= 4
000000r 2               ISR		= 5
000000r 2               IMR		= 5
000000r 2               CNTMSB		= 6
000000r 2               CNTLSB		= 7
000000r 2               MODEB		= 8
000000r 2               STATB		= 9
000000r 2               CLOCKB		= 9
000000r 2               COMMB		= 10
000000r 2               RECB		= 11
000000r 2               TRANSB		= 11
000000r 2               IVR		= 12
000000r 2               INPORT		= 13
000000r 2               OPCTRL		= 13
000000r 2               STRTCNT		= 14
000000r 2               OPSET		= 14
000000r 2               STOPCNT		= 15
000000r 2               OPRES		= 15
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 6502 CPU vectors
000000r 2               ;--------------------------------------------------------------
000000r 2               NMI		= $FFFA
000000r 2               RESET		= $FFFC
000000r 2               IRQ		= $FFFE
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; FPGA misc. stuff
000000r 2               ;--------------------------------------------------------------
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; RESET, TIMER, HARDWARE MULT.
000000r 2               ;--------------------------------------------------------------
000000r 2               SOFTRESET	= IO + $80
000000r 2               TIMERLO 	= IO + $81
000000r 2               TIMERHI		= IO + $82
000000r 2               TIMERST		= IO + $83
000000r 2               WORDLO		= IO + $84
000000r 2               WORDHI		= IO + $85
000000r 2               DOTS		= IO + $86
000000r 2               
000000r 2               CCONST5MS	= 62400-1
000000r 2               ;--------------------------------------------------------------
000000r 2               ; SPI SD-card interface
000000r 2               ;--------------------------------------------------------------
000000r 2               SPI		= IO + $90
000000r 2               SPICNTL		= SPI
000000r 2               SPISS		= SPI + 1
000000r 2               SPIDAT		= SPI + 2
000000r 2               SPISTAT		= SPI + 3
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; graphics system
000000r 2               ;--------------------------------------------------------------
000000r 2               DISP			= $FFFE00
000000r 2               colorBorderLo		= DISP + 0
000000r 2               colorBorderHi		= DISP + 1
000000r 2               colorBackgroundLo	= DISP + 2
000000r 2               colorBackgroundHi	= DISP + 3
000000r 2               color00Lo		= DISP + 4
000000r 2               color00Hi		= DISP + 5
000000r 2               screenBaseLo		= DISP + 6
000000r 2               screenBaseHi		= DISP + 7
000000r 2               screenBaseBank		= DISP + 8
000000r 2               control			= DISP + 9
000000r 2               cursorLo		= DISP + 10
000000r 2               cursorHi		= DISP + 11
000000r 2               rasterLo		= DISP + 12
000000r 2               rasterHi		= DISP + 13
000000r 2               dispStatus		= DISP + 14
000000r 2               vcountLo		= DISP + 15
000000r 2               vcountHi		= DISP + 16
000000r 2               ;spriteBaseLo		= DISP + 17
000000r 2               ;spriteBaseHi		= DISP + 18
000000r 2               spriteBaseBank		= DISP + 19
000000r 2               spriteCntl		= DISP + 20
000000r 2               sprite0addr		= DISP + 21
000000r 2               sprite1addr             = DISP + 22
000000r 2               sprite2addr             = DISP + 23
000000r 2               sprite3addr             = DISP + 24
000000r 2               sprite4addr             = DISP + 25
000000r 2               sprite5addr             = DISP + 26
000000r 2               sprite6addr             = DISP + 27
000000r 2               sprite7addr             = DISP + 28
000000r 2               xpos0			= DISP + 32
000000r 2               xpos1			= DISP + 33
000000r 2               xpos2			= DISP + 34
000000r 2               xpos3			= DISP + 35
000000r 2               xpos4			= DISP + 36
000000r 2               xpos5			= DISP + 37
000000r 2               xpos6			= DISP + 38
000000r 2               xpos7			= DISP + 39
000000r 2               xposHi			= DISP + 40
000000r 2               
000000r 2               palette 		= $FFFC00
000000r 2               spritePalette		= $FFFE40
000000r 2               sprite0			= $7E0000
000000r 2               
000000r 2               ;--------------------------------------------------------------
000000r 2               ; 16450 ACIA registers
000000r 2               ;--------------------------------------------------------------
000000r 2               ACIA0		= IO + $E0
000000r 2               RBR0		= ACIA0
000000r 2               THR0		= ACIA0
000000r 2               IER0		= ACIA0 + 1
000000r 2               IIR0		= ACIA0 + 2
000000r 2               LCR0		= ACIA0 + 3
000000r 2               MCR0		= ACIA0 + 4
000000r 2               LSR0		= ACIA0 + 5
000000r 2               MSR0		= ACIA0 + 6
000000r 2               SCR0		= ACIA0 + 7
000000r 2               DLL0		= ACIA0
000000r 2               DLM0		= ACIA0 + 1
000000r 2               
000000r 2               SECPTRLO	= ACIA0 + 8
000000r 2               SECPTRHI	= ACIA0 + 9
000000r 2               READWRITE	= ACIA0 + 10
000000r 2               BUFPTRLO	= ACIA0 + 11
000000r 2               BUFPTRHI	= ACIA0 + 12
000000r 2               
000000r 2               
000000r 1               		.include "myos.inc"
000000r 2               MYOS		= $C000
000000r 2               JMYOSSTART	= MYOS + $00
000000r 2               JREADSECTOR	= MYOS + $03
000000r 2               JSETSECTOR	= MYOS + $06
000000r 2               JWRITESECTOR	= MYOS + $09
000000r 2               JSDINIT		= MYOS + $0C
000000r 2               CIOV		= MYOS + $0F
000000r 2               JSTARTUP	= MYOS + $12
000000r 2               JPRINT		= MYOS + $15
000000r 2               JPUTHEX		= MYOS + $18
000000r 2               JPRINTSTR	= MYOS + $1B
000000r 2               JINITFAT	= MYOS + $1E
000000r 2               CIOV24		= MYOS + $21
000000r 2               
000000r 1               		.org  $a00
000A00  1               	.ENDIF
000A00  1               
000A00  1               ;234567890123456789012345678901234567890123456789012345
000A00  1               ;
000A00  1               ; In the Kingswood AS65 assembler some of the options
000A00  1               ; below must be set manually.
000A00  1               ;
000A00  1               ;    .lf  vtl02ca2.lst      (set -l in commandline)
000A00  1               ;    .cr  6502              (is default)
000A00  1               ;    .tf  vtl02ca2.obj,ap1  (set -s2 in commandline)
000A00  1               ;-----------------------------------------------------;
000A00  1               ;             VTL-2 for the 6502 (VTL02C)             ;
000A00  1               ;           Original Altair 680b version by           ;
000A00  1               ;          Frank McCoy and Gary Shannon 1977          ;
000A00  1               ;    2012: Adapted to the 6502 by Michael T. Barry    ;
000A00  1               ; Thanks to sbprojects.com for a very nice assembler! ;
000A00  1               ;-----------------------------------------------------;
000A00  1               ;        Copyright (c) 2012, Michael T. Barry
000A00  1               ;       Revision B (c) 2015, Michael T. Barry
000A00  1               ;       Revision C (c) 2015, Michael T. Barry
000A00  1               ;               All rights reserved.
000A00  1               ;
000A00  1               ; Redistribution and use in source and binary forms,
000A00  1               ;   with or without modification, are permitted,
000A00  1               ;   provided that the following conditions are met:
000A00  1               ;
000A00  1               ; 1. Redistributions of source code must retain the
000A00  1               ;    above copyright notice, this list of conditions
000A00  1               ;    and the following disclaimer.
000A00  1               ; 2. Redistributions in binary form must reproduce the
000A00  1               ;    above copyright notice, this list of conditions
000A00  1               ;    and the following disclaimer in the documentation
000A00  1               ;    and/or other materials provided with the
000A00  1               ;    distribution.
000A00  1               ;
000A00  1               ; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS
000A00  1               ; AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
000A00  1               ; WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
000A00  1               ; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
000A00  1               ; FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
000A00  1               ; SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
000A00  1               ; FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
000A00  1               ; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
000A00  1               ; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
000A00  1               ; SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
000A00  1               ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
000A00  1               ; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
000A00  1               ; OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
000A00  1               ; IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
000A00  1               ; ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
000A00  1               ;-----------------------------------------------------;
000A00  1               ; Except for the differences discussed below, VTL02 was
000A00  1               ;   designed to duplicate the OFFICIALLY DOCUMENTED
000A00  1               ;   behavior of Frank's 680b version, detailed here:
000A00  1               ;     http://www.altair680kit.com/manuals/Altair_
000A00  1               ;     680-VTL-2%20Manual-05-Beta_1-Searchable.pdf
000A00  1               ;   These versions ignore all syntax errors and plow
000A00  1               ;   through VTL-2 programs with the assumption that
000A00  1               ;   they are "correct", but in their own unique ways,
000A00  1               ;   so any claims of compatibility are null and void
000A00  1               ;   for VTL-2 code brave (or stupid) enough to stray
000A00  1               ;   from the beaten path.
000A00  1               ;
000A00  1               ; Differences between the 680b and 6502 versions:
000A00  1               ; * {&} and {*} are initialized on entry.
000A00  1               ; * Division by zero returns 65535 for the quotient and
000A00  1               ;     the dividend for the remainder (the original 6800
000A00  1               ;     version froze).
000A00  1               ; * The 6502 has NO 16-bit registers (other than PC)
000A00  1               ;     and less overall register space than the 6800,
000A00  1               ;     so the interpreter reserves some obscure VTL02C
000A00  1               ;     variables {@ $ ( ) 0 1 2 3 4 5 6 7 8 9 < > : ?}
000A00  1               ;     for its internal use (the 680b version used a
000A00  1               ;     similar tactic, but differed in the details).
000A00  1               ;     The deep nesting of parentheses also puts {; < =}
000A00  1               ;     in danger of corruption.  For example, executing
000A00  1               ;     the statement A=((((((((1)))))))) sets both {A}
000A00  1               ;     and {;} to the value 1.
000A00  1               ; * Users wishing to call a machine language subroutine
000A00  1               ;     via the system variable {>} must first set the
000A00  1               ;     system variable {"} to the proper address vector
000A00  1               ;     (for example, "=768).
000A00  1               ; * The x register is used to point to a simple VTL02C
000A00  1               ;     variable (it can't point explicitly to an array
000A00  1               ;     element like the 680b version because it's only
000A00  1               ;     8-bits).  In the comments, var[x] refers to the
000A00  1               ;     16-bit contents of the zero-page variable pointed
000A00  1               ;     to by register x (residing at addresses x, x+1).
000A00  1               ; * The y register is used as a pointer offset inside
000A00  1               ;     a VTL02C statement (easily handling the maximum
000A00  1               ;     statement length of about 128 bytes).  In the
000A00  1               ;     comments, @[y] refers to the 16-bit address
000A00  1               ;     formed by adding register y to the value in {@}.
000A00  1               ; * The structure and flow of this interpreter are
000A00  1               ;     similar to the 680b version, but have been
000A00  1               ;     reorganized in a more 6502-friendly format (the
000A00  1               ;     6502 has no 'bsr' instruction, so the 'stuffing'
000A00  1               ;     of subroutines within 128 bytes of the caller is
000A00  1               ;     only advantageous for conditional branches).
000A00  1               ; * This version is based on the original port, which
000A00  1               ;     was wound rather tightly, in a failed attempt to
000A00  1               ;     fit it into 768 bytes like the 680b version; many
000A00  1               ;     structured programming principles were sacrificed
000A00  1               ;     in that effort.  The 6502 simply requires more
000A00  1               ;     instructions than the 6800 does to manipulate 16-
000A00  1               ;     bit quantities, but the overall execution speed
000A00  1               ;     should be comparable due to the 6502's slightly
000A00  1               ;     lower average clocks/instruction ratio.  As it is
000A00  1               ;     now, it fits into 1KB with just a few bytes to
000A00  1               ;     spare, but is more feature-laden than the 680b
000A00  1               ;     interpreter whence it came.  Beginning with
000A00  1               ;     Revision C, I tried to strike a tasteful balance
000A00  1               ;     between execution speed and code size, but I
000A00  1               ;     stubbornly kept it under 1024 ROMable bytes and
000A00  1               ;     used only documented op-codes that were supported
000A00  1               ;     by the original NMOS 6502 (without the ROR bug).
000A00  1               ;     I may have missed a few optimizations -- further
000A00  1               ;     suggestions are welcome.
000A00  1               ; * VTL02C is my free gift (?) to the world.  It may be
000A00  1               ;     freely copied, shared, and/or modified by anyone
000A00  1               ;     interested in doing so, with only the stipulation
000A00  1               ;     that any liabilities arising from its use are
000A00  1               ;     limited to the price of VTL02C (nothing).
000A00  1               ;-----------------------------------------------------;
000A00  1               ; 2015: Revision B included some space optimizations
000A00  1               ;         (suggested by dclxvi) and enhancements
000A00  1               ;         (suggested by mkl0815 and Klaus2m5):
000A00  1               ;
000A00  1               ; * Bit-wise operators & | ^ (and, or, xor)
000A00  1               ;   Example:  A=$|128) Get a char and set hi-bit
000A00  1               ;
000A00  1               ; * Absolute addressed 8-bit memory load and store
000A00  1               ;   via the {< @} facility:
000A00  1               ;   Example:  <=P) Point to the I/O port at P
000A00  1               ;             @=@&254^128) Clear low-bit & flip hi-bit
000A00  1               ;
000A00  1               ; * Starting with VTL02B, the space character is no
000A00  1               ;     longer a valid user variable nor a "valid" binary
000A00  1               ;     operator.  It's now only significant as a numeric
000A00  1               ;     constant terminator and as a place-holder in
000A00  1               ;     strings and program listings, where it may be
000A00  1               ;     used to improve human readability (at a slight
000A00  1               ;     cost in execution speed and memory consumption).
000A00  1               ;   Example:
000A00  1               ;   *              (VTL-2)
000A00  1               ;       1000 A=1)         Init loop index
000A00  1               ;       1010 ?=A)           Print index
000A00  1               ;       1020 ?="")          Newline
000A00  1               ;       1030 A=A+1)         Update index
000A00  1               ;       1040 #=A<10*1010) Loop until done
000A00  1               ;
000A00  1               ;   *              (VTL02B)
000A00  1               ;       1000 A = 1             ) Init loop index
000A00  1               ;       1010     ? = A         )   Print index
000A00  1               ;       1020     ? = ""        )   Newline
000A00  1               ;       1030     A = A + 1     )   Update index
000A00  1               ;       1040 # = A < 10 * 1010 ) Loop until done
000A00  1               ;
000A00  1               ; 2015: Revision C includes further enhancements
000A00  1               ;   (suggested by Klaus2m5):
000A00  1               ;
000A00  1               ; * "THEN" and "ELSE" operators [ ]
000A00  1               ;     A[B returns 0 if A is 0, otherwise returns B.
000A00  1               ;     A]B returns B if A is 0, otherwise returns 0.
000A00  1               ;
000A00  1               ; * Some effort was made to balance interpreter code
000A00  1               ;     density with interpreter performance, while
000A00  1               ;     remaining within the 1KB constraint.  Structured
000A00  1               ;     programming principles remained at low priority.
000A00  1               ;-----------------------------------------------------;
000A00  1               ; VTL02C variables occupy RAM addresses $0080 to $00ff,
000A00  1               ;   and are little-endian, in the 6502 tradition.
000A00  1               ; The use of lower-case and some control characters for
000A00  1               ;   variable names is allowed, but not recommended; any
000A00  1               ;   attempts to do so would likely result in chaos, due
000A00  1               ;   to aliasing with upper-case and system variables.
000A00  1               ; Variables tagged with an asterisk are used internally
000A00  1               ;   by the interpreter and may change without warning.
000A00  1               ;   {@ $ ( ) 0..9 : > ?} are (usually) intercepted by
000A00  1               ;   the interpreter, so their internal use by VTL02C is
000A00  1               ;   "safe".  The same cannot be said for {; < =}, so be
000A00  1               ;   careful!
000A00  1               ; VTL02C system variable space
000A00  1               spacevar   = $80      ; { }  Starting with VTL02B:  the
000A00  1               ;                       space character is no longer a
000A00  1               ;                       valid user variable nor a
000A00  1               ;                       "valid" binary operator.
000A00  1               ;                       It is now only significant as a
000A00  1               ;                       numeric constant terminator and
000A00  1               ;                       as a place-holder in strings
000A00  1               ;                       and program listings.
000A00  1               bang     = $82      ; {!}  return line number
000A00  1               quote    = $84      ; {"}  user ml subroutine vector
000A00  1               pound    = $86      ; {#}  current line number
000A00  1               dolr     = $88      ; {$}* temp storage / char i/o
000A00  1               remn     = $8A      ; {%}  remainder of last division
000A00  1               ampr     = $8C      ; {&}  pointer to start of array
000A00  1               tick     = $8E      ; {'}  pseudo-random number
000A00  1               lparen   = $90      ; {(}* old line # / begin sub-exp
000A00  1               rparen   = $92      ; {)}* temp storage / end sub-exp
000A00  1               star     = $94      ; {*}  pointer to end of free mem
000A00  1               ;          $96      ; {+ , - . /}  valid variables
000A00  1               ; Interpreter argument stack space
000A00  1               arg      = $A0      ; {0 1 2 3 4 5 6 7 8 9 :}*
000A00  1               ; Rarely used variables and argument stack overflow
000A00  1               ;          $B6      ; {;}* valid user variable
000A00  1               lthan    = $B8      ; {<}* user memory byte pointer
000A00  1               equal    = $BA      ; {=}* valid user variable (now used as 24-bit pointer)
000A00  1               gthan    = $BC      ; {>}* temp / call ML subroutine
000A00  1               ques     = $BE      ; {?}* temp / terminal i/o
000A00  1               at       = $C0      ; {@}* internal pointer / mem byte
000A00  1               ; VTL02C standard user variable space
000A00  1               ;                     {A B C .. X Y Z [ \ ] ^ _}
000A00  1               
000A00  1               ;
000A00  1               nulstk   = $01ff    ; system stack resides in page 1
000A00  1               ;-----------------------------------------------------;
000A00  1               ; Equates for a 48K+ Apple 2 (original, +, e, c, gs)
000A00  1               ;ESC      = 27       ; "Cancel current input line" key
000A00  1               ;BS       = 8        ; "Delete last keypress" key
000A00  1               ;OP_OR    = '!'      ; Bit-wise OR operator
000A00  1               ;linbuf   = $0200    ; input line buffer
000A00  1               ;prgm     = $0800    ; VTL02B program grows from here
000A00  1               ;himem    = $8000    ;   ... up to the top of user RAM
000A00  1               ;vtl02c   = $8000    ; interpreter cold entry point
000A00  1               ;                     (warm entry point is startok)
000A00  1               ;KBD      = $c000    ; 128 + keypress if waiting
000A00  1               ;KEYIN    = $fd0c    ; apple monitor keyin routine
000A00  1               ;COUT     = $fded    ; apple monitor charout routine
000A00  1               ;-----------------------------------------------------;
000A00  1               ; Equates for the 2m5 SBC emulator
000A00  1               ;ESC      = 27       ; "Cancel current input line" key
000A00  1               BS       = 8        ; "Delete last keypress" key
000A00  1               OP_OR    = '|'      ; Bit-wise OR operator
000A00  1               linbuf   = $0380    ; input line buffer
000A00  1               prgm     = $1000    ; VTL02B program grows from here
000A00  1               himem    = $C000    ;   ... up to the top of user RAM
000A00  1               ;vtl02c   = $fb00    ; interpreter cold entry point
000A00  1               ;                     (warm entry point is startok)
000A00  1               ;io_area  = $bf00      ;configure emulator terminal I/O
000A00  1               ;acia_tx  = io_area+$f0  ;acia tx data register
000A00  1               ;acia_rx  = io_area+$f0  ;acia rx data register
000A00  1               ;acia_st  = io_area+$ff  ;bit 0 = 10ms tick
000A00  1               ;=====================================================;
000A00  1               ;		.org  $a00
000A00  1               ;-----------------------------------------------------;
000A00  1               ; T E S T code
000A00  1               ;tloop:
000A00  1               ;	jsr	jchrin
000A00  1               ;	jsr	jprinthex
000A00  1               ;	jmp tloop
000A00  1               
000A00  1               ;-----------------------------------------------------;
000A00  1               ; Initialize program area pointers and start VTL02C
000A00  1               ; 17 bytes
000A00  1               
000A00  1               VTL02C:
000A00  1  A9 00        		lda	#<(prgm)
000A02  1  85 8C        		sta	ampr       ; {&} -> empty program
000A04  1  A9 10        		lda	#>(prgm)
000A06  1  85 8D        		sta	ampr+1
000A08  1  A9 00        		lda	#<(himem)
000A0A  1  85 94        		sta	star       ; {*} -> top of user RAM
000A0C  1  A9 C0        		lda	#>(himem)
000A0E  1  85 95        		sta	star+1
000A10  1               
000A10  1  3B           		tsc		   ; save stack-pointer
000A11  1  85 80        		sta	spacevar
000A13  1  EB           		xba
000A14  1  85 81        		sta	spacevar+1
000A16  1               
000A16  1               startok:
000A16  1  38           		sec                ; request "OK" message
000A17  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000A17  1               ; Start/restart VTL02C command line with program intact
000A17  1               ; 32 bytes
000A17  1               start:
000A17  1               
000A17  1               ;		cld             ; a sensible precaution
000A17  1               ;		ldx  <(nulstk)
000A17  1               ;		txs             ; drop whatever is on the stack
000A17  1               
000A17  1  A5 81        		lda	spacevar+1
000A19  1  EB           		xba
000A1A  1  A5 80        		lda	spacevar
000A1C  1  1B           		tcs
000A1D  1               
000A1D  1  90 10        		bcc	user       ; skip "OK" if carry clear
000A1F  1  20 3F 0C     		jsr	outnl
000A22  1  A9 4F        		lda	#'O'       ; output \nOK\n to terminal
000A24  1  20 FB 0E     		jsr	outch
000A27  1  A9 4B        		lda	#'K'
000A29  1  20 FB 0E     		jsr	outch
000A2C  1  20 3F 0C     		jsr	outnl
000A2F  1               user:
000A2F  1  20 64 0E     		jsr	inln       ; input a line from the user
000A32  1  B2 C0        		lda	(at)
000A34  1  C9 58        		cmp	#'X'
000A36  1  D0 01        		bne	user1
000A38  1  6B           		rtl
000A39  1               user1:
000A39  1  A2 86        		ldx	#pound     ; cvbin destination = {#}
000A3B  1  20 3B 0E     		jsr	cvbin      ; does line start with a number?
000A3E  1  F0 39        		beq	direct     ;   no: execute direct statement
000A40  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000A40  1               ; Delete/insert/replace program line or list program
000A40  1               ; 7 bytes
000A40  1               stmnt:
000A40  1  18           		clc
000A41  1  A5 86        		lda	pound
000A43  1  05 87        		ora	pound+1    ; {#} = 0?
000A45  1  D0 4D        		bne	skp2       ;   no: delete/insert/replace line
000A47  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000A47  1               ; List program to terminal and restart "OK" prompt
000A47  1               ; entry:  Carry must be clear
000A47  1               ; uses:   findln:, outch:, prnum:, prstr:, {@ ( )}
000A47  1               ; exit:   to command line via findln:
000A47  1               ; 20 bytes
000A47  1               list_:
000A47  1  20 2B 0B     		jsr	findln     ; find program line >= {#}
000A4A  1  A2 90        		ldx	#lparen    ; line number for prnum
000A4C  1  20 9A 0C     		jsr	prnum      ; print the line number
000A4F  1  A9 20        		lda	#' '       ; print a space instead of the
000A51  1  20 FB 0E     		jsr	outch      ;   line length byte
000A54  1  A9 00        		lda	#0         ; zero for delimiter
000A56  1  20 0C 0C     		jsr	prstr      ; print the rest of the line
000A59  1  B0 EC        		bcs	list_      ; (always taken)
000A5B  1               ;-----------------------------------------------------;
000A5B  1               ; The main program execution loop
000A5B  1               ; entry:  with (cs) via "beq direct" in user:
000A5B  1               ; exit:   to command line via findln: or "beq start"
000A5B  1               ; 45 bytes
000A5B  1               progr:
000A5B  1  F0 14        		beq	eloop0     ; if {#} = 0 then ignore and
000A5D  1  A4 91        		ldy	lparen+1   ;   continue (false branch)
000A5F  1  A6 90        		ldx	lparen     ; else did {#} change?
000A61  1  C4 87        		cpy	pound+1    ;   yes: perform a branch, with
000A63  1  D0 04        		bne	branch     ;     carry flag conditioned for
000A65  1  E4 86        		cpx	pound      ;     the appropriate direction.
000A67  1  F0 0C        		beq	eloop      ;   no: execute next line (cs)
000A69  1               branch:
000A69  1  E8           		inx                ;   execute a VTL02B branch
000A6A  1  D0 01        		bne	branch2
000A6C  1  C8           		iny
000A6D  1               branch2:
000A6D  1  86 82        		stx	bang       ;   {!} = {(} + 1 (return ptr)
000A6F  1  84 83        		sty	bang+1
000A71  1               eloop0:
000A71  1  2A           		rol	a
000A72  1  49 01        		eor	#1         ; complement carry flag
000A74  1  6A           		ror	a
000A75  1               eloop:
000A75  1  20 2B 0B     		jsr	findln     ; find first/next line >= {#}
000A78  1  C8           		iny		   ; skip over the length byte
000A79  1               direct:
000A79  1  08           		php            	   ; (cc: program, cs: direct)
000A7A  1  AD 2D 03     		lda	IRQPS2S
000A7D  1  D0 07        		bne	direct1
000A7F  1  20 F3 0E     		jsr	inch
000A82  1  C9 03        		cmp	#3
000A84  1  F0 91        		beq	start
000A86  1               direct1:
000A86  1  20 44 0C     		jsr	exec       ; execute one VTL02B statement
000A89  1  28           		plp
000A8A  1  A5 86        		lda	pound      ; update Z for {#}
000A8C  1  05 87        		ora	pound+1    ; if program mode then continue
000A8E  1  90 CB        		bcc	progr      ; if direct mode, did {#} change?
000A90  1  F0 85        		beq	start      ;   no: restart "OK" prompt
000A92  1  D0 DD        		bne	eloop0     ;   yes: execute program from {#}
000A94  1               ;-----------------------------------------------------;
000A94  1               ; Delete/insert/replace program line and restart the
000A94  1               ;   command prompt (no "OK" means success)
000A94  1               ; entry:  Carry must be clear
000A94  1               ; uses:   find:, start:, linbuf, {@ > # & * (}
000A94  1               ; 151 bytes
000A94  1               skp2:
000A94  1  98           		tya                ; save linbuf offset pointer
000A95  1  48           		pha
000A96  1  20 9C 0E     		jsr	find       ; point {@} to first line >= {#}
000A99  1  B0 34        		bcs	insrt
000A9B  1  45 86        		eor	pound      ; if line doesn't already exist
000A9D  1  D0 30        		bne	insrt      ; then skip deletion process
000A9F  1  E4 87        		cpx	pound+1
000AA1  1  D0 2C        		bne	insrt
000AA3  1  AA           		tax	           ; x = 0
000AA4  1  B1 C0        		lda	(at),y
000AA6  1  A8           		tay	           ; y = length of line to delete
000AA7  1  49 FF        		eor	#$ff
000AA9  1  65 8C        		adc	ampr       ; {&} = {&} - y
000AAB  1  85 8C        		sta	ampr
000AAD  1  B0 02        		bcs	delt
000AAF  1  C6 8D        		dec	ampr+1
000AB1  1               delt:
000AB1  1  A5 C0        		lda	at
000AB3  1  85 BC        		sta	gthan      ; {>} = {@}
000AB5  1  A5 C1        		lda	at+1
000AB7  1  85 BD        		sta	gthan+1
000AB9  1               delt2:
000AB9  1  A5 BC        		lda	gthan
000ABB  1  C5 8C        		cmp	ampr       ; delete the line
000ABD  1  A5 BD        		lda	gthan+1
000ABF  1  E5 8D        		sbc	ampr+1
000AC1  1  B0 0C        		bcs	insrt
000AC3  1  B1 BC        		lda	(gthan),y
000AC5  1  81 BC        		sta	(gthan,x)
000AC7  1  E6 BC        		inc	gthan
000AC9  1  D0 EE        		bne	delt2
000ACB  1  E6 BD        		inc	gthan+1
000ACD  1  90 EA        		bcc	delt2      ; (always taken)
000ACF  1               insrt:
000ACF  1  68           		pla
000AD0  1  AA           		tax	           ; x = linbuf offset pointer
000AD1  1  A5 86        		lda	pound
000AD3  1  48           		pha	           ; push the new line number on
000AD4  1  A5 87        		lda	pound+1    ;   the system stack
000AD6  1  48           		pha
000AD7  1  A0 02        		ldy	#2
000AD9  1               cntln:
000AD9  1  E8           		inx
000ADA  1  C8           		iny	           ; determine new line length in y
000ADB  1  BD 7F 03     		lda	linbuf-1,x ;   and push statement string on
000ADE  1  48           		pha	           ;   the system stack
000ADF  1  D0 F8        		bne	cntln
000AE1  1  C0 04        		cpy	#4         ; if empty line then skip the
000AE3  1  90 43        		bcc	jstart     ;   insertion process
000AE5  1  AA           		tax	           ; x = 0
000AE6  1  98           		tya
000AE7  1  18           		clc
000AE8  1  65 8C        		adc	ampr       ; calculate new program end
000AEA  1  85 BC        		sta	gthan      ; {>} = {&} + y
000AEC  1  8A           		txa
000AED  1  65 8D        		adc	ampr+1
000AEF  1  85 BD        		sta	gthan+1
000AF1  1  A5 BC        		lda	gthan
000AF3  1  C5 94        		cmp	star       ; if {>} >= {*} then the program
000AF5  1  A5 BD        		lda	gthan+1    ;   won't fit in available RAM,
000AF7  1  E5 95        		sbc	star+1     ;   so drop the stack and abort
000AF9  1  B0 2D        		bcs	jstart     ;   to the "OK" prompt
000AFB  1               slide:
000AFB  1  A5 8C        		lda	ampr
000AFD  1  D0 02        		bne	slide2
000AFF  1  C6 8D        		dec	ampr+1
000B01  1               slide2:
000B01  1  C6 8C        		dec	ampr
000B03  1  A5 8C        		lda	ampr
000B05  1  C5 C0        		cmp	at
000B07  1  A5 8D        		lda	ampr+1
000B09  1  E5 C1        		sbc	at+1
000B0B  1  90 06        		bcc	move       ; slide open a gap inside the
000B0D  1  A1 8C        		lda	(ampr,x)   ;   program just big enough to
000B0F  1  91 8C        		sta	(ampr),y   ;   hold the new line
000B11  1  B0 E8        		bcs	slide      ; (always taken)
000B13  1               move:
000B13  1  98           		tya
000B14  1  AA           		tax	           ; x = new line length
000B15  1               move2:
000B15  1  68           		pla	           ; pull the statement string and
000B16  1  88           		dey	           ;   the new line number and store
000B17  1  91 C0        		sta	(at),y     ;   them in the program gap
000B19  1  D0 FA        		bne	move2
000B1B  1  A0 02        		ldy	#2
000B1D  1  8A           		txa
000B1E  1  91 C0        		sta	(at),y     ; store length after line number
000B20  1  A5 BC        		lda	gthan
000B22  1  85 8C        		sta	ampr       ; {&} = {>}
000B24  1  A5 BD        		lda	gthan+1
000B26  1  85 8D        		sta	ampr+1
000B28  1               jstart:
000B28  1  4C 17 0A     		jmp	start      ; drop stack, restart cmd prompt
000B2B  1               ;-----------------------------------------------------;
000B2B  1               ; Point @[y] to the first/next program line >= {#}
000B2B  1               ; entry:   (cc): start search at beginning of program
000B2B  1               ;          (cs): start search at next line
000B2B  1               ;          ({@} -> beginning of current line)
000B2B  1               ; used by: list_:, progr:
000B2B  1               ; uses:    find:, jstart:, prgm, {@ # & (}
000B2B  1               ; exit:    if line not found then abort to "OK" prompt
000B2B  1               ;          else {@} -> found line, x:a = {#} = {(} =
000B2B  1               ;            actual line number, y = 2, (cc)
000B2B  1               ; 10 bytes
000B2B  1               findln:
000B2B  1  20 9C 0E     		jsr	find       ; find first/next line >= {#}
000B2E  1  B0 F8        		bcs	jstart     ; if end then restart "OK" prompt
000B30  1  85 86        		sta	pound      ; {#} = {(}
000B32  1  86 87        		stx	pound+1
000B34  1  60           		rts
000B35  1               ;
000B35  1               ;
000B35  1               ;
000B35  1               loadsave:
000B35  1  A2 10        		ldx	#$10
000B37  1  29 08        		and	#$08	  	 ; 8=save, 0=load
000B39  1  D0 02        		bne	loadsave8
000B3B  1  A9 04        		lda	#4
000B3D  1  9D 8A 02     loadsave8:	sta	ICAX1,x
000B40  1  68           		pla
000B41  1               
000B41  1               loadsave5:
000B41  1  B1 C0        		lda	(at),y
000B43  1  F0 0A        		beq	loadsave1
000B45  1  C9 22        		cmp	#'"'
000B47  1  F0 06        		beq	loadsave1
000B49  1  99 7D 03     		sta	FNAME-3,y
000B4C  1  C8           		iny
000B4D  1  10 F2        		bpl	loadsave5
000B4F  1               
000B4F  1  A9 0A        loadsave1:	lda	#EOL
000B51  1  99 7D 03     		sta	FNAME-3,y
000B54  1               
000B54  1  20 04 0C     		jsr	close
000B57  1               
000B57  1  A9 03        		lda	#OPEN
000B59  1  9D 82 02     		sta	ICCOM,x
000B5C  1  A9 00        		lda	#0
000B5E  1  9D 8B 02     		sta	ICAX2,x
000B61  1  9D 86 02     		sta	ICBAB,x
000B64  1  9D 88 02     		sta	ICBLH,x
000B67  1  9D 89 02     		sta	ICBLB,x
000B6A  1  A9 80        		lda	#<FNAME
000B6C  1  9D 84 02     		sta	ICBAL,x
000B6F  1  A9 03        		lda	#>FNAME
000B71  1  9D 85 02     		sta	ICBAH,x
000B74  1  8A           		txa
000B75  1  9D 87 02     		sta	ICBLL,x
000B78  1  20 0F C0     		jsr	CIOV
000B7B  1  30 6C        		bmi	error
000B7D  1               
000B7D  1  A9 FF        		lda	#$FF
000B7F  1  8D 80 03     		sta	FNAME
000B82  1  8D 81 03     		sta	FNAME+1
000B85  1  A9 00        		lda	#<prgm
000B87  1  8D 82 03     		sta	FNAME+2
000B8A  1  A9 10        		lda	#>prgm
000B8C  1  8D 83 03     		sta	FNAME+3
000B8F  1               
000B8F  1  38           		sec
000B90  1  A5 8C        		lda	ampr
000B92  1  E9 01        		sbc	#1
000B94  1  8D 84 03     		sta	FNAME+4
000B97  1  A5 8D        		lda	ampr+1
000B99  1  E9 00        		sbc	#0
000B9B  1  8D 85 03     		sta	FNAME+5
000B9E  1               
000B9E  1  A9 0B        		lda	#PUTCHR
000BA0  1  BC 8A 02     		ldy	ICAX1,x
000BA3  1  C0 08        		cpy	#8
000BA5  1  F0 02        		beq	loadsave4
000BA7  1  A9 07        		lda	#GETCHR
000BA9  1  9D 82 02     loadsave4:	sta	ICCOM,x
000BAC  1  A9 06        		lda	#6
000BAE  1  9D 87 02     		sta	ICBLL,x
000BB1  1  20 0F C0     		jsr	CIOV
000BB4  1  30 33        		bmi	error
000BB6  1               
000BB6  1  A9 00        		lda	#<prgm
000BB8  1  9D 84 02     		sta	ICBAL,x
000BBB  1  A9 10        		lda	#>prgm
000BBD  1  9D 85 02     		sta	ICBAH,x
000BC0  1               
000BC0  1  BD 82 02     		lda	ICCOM,x
000BC3  1  C9 0B        		cmp	#PUTCHR
000BC5  1  F0 29        		beq	save
000BC7  1               
000BC7  1  EE 84 03     		inc	FNAME+4
000BCA  1  D0 03        		bne	loadsave7
000BCC  1  EE 85 03     		inc	FNAME+5
000BCF  1  38           loadsave7:	sec
000BD0  1  AD 84 03     		lda	FNAME+4
000BD3  1  85 8C        		sta	ampr
000BD5  1  ED 82 03     		sbc	FNAME+2
000BD8  1  9D 87 02     		sta	ICBLL,x
000BDB  1  AD 85 03     		lda	FNAME+5
000BDE  1  85 8D        		sta	ampr+1
000BE0  1  ED 83 03     		sbc	FNAME+3
000BE3  1  9D 88 02     		sta	ICBLH,x
000BE6  1  4C FF 0B     		jmp	loadsave6
000BE9  1               
000BE9  1  98           error:		tya
000BEA  1  20 0C E0     		jsr	jprinthex
000BED  1  4C 04 0C     		jmp	close
000BF0  1               
000BF0  1               save:
000BF0  1  38           		sec
000BF1  1  A5 8C        		lda	ampr
000BF3  1  E9 00        		sbc	#<prgm
000BF5  1  9D 87 02     		sta	ICBLL,x
000BF8  1  A5 8D        		lda	ampr+1
000BFA  1  E9 10        		sbc	#>prgm
000BFC  1  9D 88 02     		sta	ICBLH,x
000BFF  1               loadsave6:
000BFF  1  20 0F C0     		jsr	CIOV
000C02  1  30 E5        		bmi	error
000C04  1               
000C04  1               close:
000C04  1  A9 0C        		lda	#CLOSE
000C06  1  9D 82 02     		sta	ICCOM,x
000C09  1  4C 0F C0     		jmp	CIOV
000C0C  1               
000C0C  1               ;-----------------------------------------------------;
000C0C  1               ; {?="...} handler; called from exec:
000C0C  1               ; List line handler; called from list_:
000C0C  1               ; 2 bytes
000C0C  1               prstr:
000C0C  1  C8           		iny                ; skip over the " or length byte
000C0D  1  48           		pha
000C0E  1  B5 00        		lda	0,x
000C10  1  C9 BA        		cmp	#$BA	   ; "}", save
000C12  1  F0 04        		beq	prstr2
000C14  1  C9 B6        		cmp	#$B6	   ; "{", load
000C16  1  D0 03        		bne	prstr1
000C18  1  4C 35 0B     prstr2:		jmp	loadsave
000C1B  1               prstr1:
000C1B  1  68           		pla
000C1C  1  AA           		tax                ; x = delimiter, fall through
000C1D  1               ;		ldx	#$22
000C1D  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000C1D  1               ; Print a string at @[y]
000C1D  1               ; x holds the delimiter char, which is skipped over,
000C1D  1               ;   not printed (a null byte is always a delimiter)
000C1D  1               ; If a key was pressed, it pauses for another keypress
000C1D  1               ;   before returning.  If either of those keys was a
000C1D  1               ;   ctrl-C, it drops the stack and restarts the "OK"
000C1D  1               ;   prompt with the user program intact
000C1D  1               ; entry:  @[y] -> string, x = delimiter char
000C1D  1               ; uses:   inch:, inkey:, jstart:, outch:, execrts:
000C1D  1               ; exit:   (normal) @[y] -> null or byte after delimiter
000C1D  1               ;         (ctrl-C) drop the stack & restart "OK" prompt
000C1D  1               ; 39 bytes
000C1D  1               prmsg:
000C1D  1  8A           		txa
000C1E  1  D1 C0        		cmp	(at),y     ; found delimiter or null?
000C20  1  F0 0A        		beq	prmsg2     ; yes: finish up
000C22  1  B1 C0        		lda	(at),y
000C24  1  F0 06        		beq	prmsg2
000C26  1  20 FB 0E     		jsr	outch      ; no: print char to terminal
000C29  1  C8           		iny	           ;   and loop (with safety escape)
000C2A  1  10 F1        		bpl	prmsg
000C2C  1               prmsg2:
000C2C  1  AA           		tax	           ; save closing delimiter
000C2D  1  20 E4 0E     		jsr	inkey      ; any key = pause?
000C30  1               ; patch - remove garbage output when halting print
000C30  1  90 03        		bcc	prout      ;   no: proceed
000C32  1  20 F3 0E     		jsr	inch       ;   yes: wait for another key
000C35  1               prout:
000C35  1  8A           		txa	           ; retrieve closing delimiter
000C36  1  F0 07        		beq	outnl      ; always \n after null delimiter
000C38  1  20 DA 0E     		jsr	skpbyte    ; skip over the delimiter
000C3B  1  C9 3B        		cmp	#';'       ; if trailing char is ';' then
000C3D  1  F0 4F        		beq	execrts    ;   suppress the \n
000C3F  1               ;		bne	outnl      ;   suppress the \n
000C3F  1               ;		rts
000C3F  1               outnl:
000C3F  1  A9 0A        		lda	#EOL       ; \n to terminal
000C41  1               joutch:
000C41  1  4C FB 0E     		jmp	outch
000C44  1               
000C44  1               
000C44  1               ;-----------------------------------------------------;
000C44  1               ; Execute a (hopefully) valid VTL02C statement at @[y]
000C44  1               ; entry:   @[y] -> left-side of statement
000C44  1               ; uses:    nearly everything
000C44  1               ; exit:    note to machine language subroutine {>=...}
000C44  1               ;            users: no registers or variables are
000C44  1               ;            required to be preserved except the system
000C44  1               ;            stack pointer, the text base pointer {@},
000C44  1               ;            and the original line number {(}
000C44  1               ; if there is a {"} directly after the assignment
000C44  1               ;   operator, the statement will execute as {?="...},
000C44  1               ;   regardless of the variable named on the left side
000C44  1               ; 84 bytes
000C44  1               exec:
000C44  1  20 DB 0E     		jsr	getbytevtl    ; fetch left-side variable name
000C47  1  F0 45        		beq	execrts    ; do nothing with a null statement
000C49  1  C9 29        		cmp	#')'       ; same for a full-line comment
000C4B  1  F0 41        		beq	execrts
000C4D  1  C8           		iny
000C4E  1  A2 A0        		ldx	#arg       ; initialize argument pointer
000C50  1  20 31 0D     		jsr	convp      ; arg[{0}] -> left-side variable
000C53  1  20 DB 0E     		jsr	getbytevtl    ; skip over assignment operator
000C56  1  20 DA 0E     		jsr	skpbyte    ; is right-side a literal string?
000C59  1  C9 22        		cmp	#'"'       ;   yes: print the string with
000C5B  1  F0 AF        		beq	prstr      ;     trailing ';' check & return
000C5D  1  A2 A2        		ldx	#arg+2     ; point eval to arg[{1}]
000C5F  1  20 C5 0C     		jsr	eval       ; evaluate right-side in arg[{1}]
000C62  1  A5 A2        		lda	arg+2
000C64  1  A0 00        		ldy	#0
000C66  1  A6 A1        		ldx	arg+1      ; was left-side an array element?
000C68  1  D0 12        		bne	exec3      ;   yes: skip to default actions
000C6A  1  A6 A0        		ldx	arg
000C6C  1  E0 C0        		cpx	#at        ; if {@=...} statement then poke
000C6E  1  F0 25        		beq	poke       ;   low half of arg[{1}] to ({<})
000C70  1  E0 88        		cpx	#dolr      ; if {$=...} statement then print
000C72  1  F0 CD        		beq	joutch     ;   arg[{1}] as ASCII character
000C74  1  E0 BE        		cpx	#ques      ; if {?=...} statement then print
000C76  1  F0 20        		beq	prnum0     ;   arg[{1}] as unsigned decimal
000C78  1  E0 BC        		cpx	#gthan     ; if {>=...} statement then call
000C7A  1  F0 13        		beq	usr        ;   user-defined ml routine
000C7C  1               exec3:
000C7C  1  91 A0        		sta	(arg),y
000C7E  1  65 8F        		adc	tick+1     ; store arg[{1}] in the left-side
000C80  1  2A           		rol	a          ;   variable
000C81  1  AA           		tax
000C82  1  C8           		iny
000C83  1  A5 A3        		lda	arg+3
000C85  1  91 A0        		sta	(arg),y
000C87  1  65 8E        		adc	tick       ; pseudo-randomize {'}
000C89  1  2A           		rol	a
000C8A  1  85 8F        		sta	tick+1
000C8C  1  86 8E        		stx	tick
000C8E  1               execrts:
000C8E  1  60           		rts
000C8F  1               
000C8F  1               usr:
000C8F  1  AA           		tax                ; jump to user ml routine with
000C90  1  A5 A3        		lda	arg+3      ;   arg[{1}] in a:x (MSB:LSB)
000C92  1  6C 84 00     		jmp	(quote)    ; {"} must point to valid 6502 code
000C95  1               poke:
000C95  1  87 B8        		sta	[lthan]
000C97  1  60           		rts
000C98  1               ;-----------------------------------------------------;
000C98  1               ; {?=...} handler; called by exec:
000C98  1               ; 2 bytes
000C98  1               prnum0:
000C98  1  A2 A2        		ldx	#arg+2     ; x -> arg[{1}], fall through
000C9A  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000C9A  1               ; Print an unsigned decimal number (0..65535) in var[x]
000C9A  1               ; entry:   var[x] = number to print
000C9A  1               ; uses:    div:, outch:, var[x+2], saves original {%}
000C9A  1               ; exit:    var[x] = 0, var[x+2] = 10
000C9A  1               ; 43 bytes
000C9A  1               prnum:
000C9A  1  A5 8A        		lda	remn
000C9C  1  48           		pha                ; save {%}
000C9D  1  A5 8B        		lda	remn+1
000C9F  1  48           		pha
000CA0  1  A9 00        		lda	#0         ; null delimiter for print
000CA2  1  48           		pha
000CA3  1  95 03        		sta	3,x
000CA5  1  A9 0A        		lda	#10        ; divisor = 10
000CA7  1  95 02        		sta	2,x        ; repeat {
000CA9  1               prnum2:
000CA9  1  20 10 0E     		jsr	div        ;   divide var[x] by 10
000CAC  1  A5 8A        		lda	remn
000CAE  1  09 30        		ora	#'0'       ;   convert remainder to ASCII
000CB0  1  48           		pha	           ;   stack digits in ascending
000CB1  1  B5 00        		lda	0,x        ;     order ('0' for zero)
000CB3  1  15 01        		ora	1,x
000CB5  1  D0 F2        		bne	prnum2     ; } until var[x] is 0
000CB7  1  68           		pla
000CB8  1               prnum3:
000CB8  1  20 FB 0E     		jsr	outch      ; print digits in descending
000CBB  1  68           		pla	           ;   order until delimiter is
000CBC  1  D0 FA        		bne	prnum3     ;   encountered
000CBE  1  68           		pla
000CBF  1  85 8B        		sta	remn+1     ; restore {%}
000CC1  1  68           		pla
000CC2  1  85 8A        		sta	remn
000CC4  1  60           		rts
000CC5  1               ;-----------------------------------------------------;
000CC5  1               ; Evaluate a (hopefully) valid VTL02C expression at
000CC5  1               ;   @[y] and place its calculated value in arg[x]
000CC5  1               ; A VTL02C expression is defined as a string of one or
000CC5  1               ;   more terms, separated by operators and terminated
000CC5  1               ;   with a null or an unmatched right parenthesis
000CC5  1               ; A term is defined as a variable name, a decimal
000CC5  1               ;   constant, or a parenthesized sub-expression; terms
000CC5  1               ;   are evaluated strictly from left to right
000CC5  1               ; A variable name is defined as a user variable, an
000CC5  1               ;   array element expression enclosed in {: )}, or a
000CC5  1               ;   system variable (which may have side-effects)
000CC5  1               ; entry:   @[y] -> expression text, x -> argument
000CC5  1               ; uses:    getval:, oper:, {@}, argument stack area
000CC5  1               ; exit:    arg[x] = result, @[y] -> next text
000CC5  1               ; 31 bytes
000CC5  1               eval:
000CC5  1  A9 00        		lda	#0
000CC7  1  95 00        		sta	0,x        ; start evaluation by simulating
000CC9  1  95 01        		sta	1,x        ;   {0+expression}
000CCB  1  A9 2B        		lda	#'+'
000CCD  1               notdn:
000CCD  1  48           		pha	           ; stack alleged operator
000CCE  1  E8           		inx	           ; advance the argument stack
000CCF  1  E8           		inx	           ;   pointer
000CD0  1  20 E4 0C     		jsr	getval     ; arg[x+2] = value of next term
000CD3  1  CA           		dex
000CD4  1  CA           		dex
000CD5  1  68           		pla	           ; retrieve and apply the operator
000CD6  1  20 8D 0D     		jsr	oper       ;   to arg[x], arg[x+2]
000CD9  1  20 DB 0E     		jsr	getbytevtl    ; end of expression?
000CDC  1  F0 05        		beq	evalrts    ;   (null or right parenthesis)
000CDE  1  C8           		iny
000CDF  1  C9 29        		cmp	#')'       ;   no: skip over the operator
000CE1  1  D0 EA        		bne	notdn      ;     and continue the evaluation
000CE3  1               evalrts:
000CE3  1  60           		rts                ;   yes: return with final result
000CE4  1               ;-----------------------------------------------------;
000CE4  1               ; Get numeric value of the term at @[y] into var[x]
000CE4  1               ; Some examples of valid terms:  123, $, H, (15-:J)/?)
000CE4  1               ; 83 bytes
000CE4  1               getval:
000CE4  1  20 3B 0E     		jsr	cvbin      ; decimal number at @[y]?
000CE7  1  D0 47        		bne	getrts     ;   yes: return with it in var[x]
000CE9  1  20 DB 0E     		jsr	getbytevtl
000CEC  1  C8           		iny
000CED  1  C9 3F        		cmp	#'?'       ; user line input?
000CEF  1  D0 17        		bne	getval2
000CF1  1  98           		tya	           ;   yes:
000CF2  1  48           		pha
000CF3  1  A5 C0        		lda	at         ;     save @[y]
000CF5  1  48           		pha	           ;     (current expression ptr)
000CF6  1  A5 C1        		lda	at+1
000CF8  1  48           		pha
000CF9  1  20 64 0E     		jsr	inln       ; input expression from user
000CFC  1  20 C5 0C     		jsr	eval       ; evaluate, var[x] = result
000CFF  1  68           		pla
000D00  1  85 C1        		sta	at+1
000D02  1  68           		pla
000D03  1  85 C0        		sta	at         ; restore @[y]
000D05  1  68           		pla
000D06  1  A8           		tay
000D07  1  60           		rts                ; skip over "?" and return
000D08  1               getval2:
000D08  1  C9 24        		cmp	#'$'       ; user char input?
000D0A  1  D0 05        		bne	getval2a
000D0C  1  20 F3 0E     		jsr	inch       ;   yes: input one char
000D0F  1  B0 1D        		bcs	getval5    ;     (always taken)
000D11  1               getval2a:
000D11  1  C9 40        		cmp	#'@'       ; memory access?
000D13  1  D0 04        		bne	getval3
000D15  1               		;sty	dolr       ;   yes:
000D15  1               		;ldy	#0
000D15  1  A7 B8        		lda	[lthan]	   ;     access memory byte at ({<})
000D17  1               		;ldy	dolr
000D17  1               		;bne	getval5    ;     (always taken)
000D17  1  80 15        		bra	getval5    ;     (always taken)
000D19  1               getval3:
000D19  1  C9 28        		cmp	#'('       ; sub-expression?
000D1B  1  F0 A8        		beq	eval       ;   yes: evaluate it recursively
000D1D  1  20 31 0D     		jsr	convp      ;   no: first set var[x] to the
000D20  1  A1 00        		lda	(0,x)      ;     named variable's address,
000D22  1  48           		pha	           ;     then replace that address
000D23  1  F6 00        		inc	0,x        ;     with the variable's actual
000D25  1  D0 02        		bne	getval4    ;     value before returning
000D27  1  F6 01        		inc	1,x
000D29  1               getval4:
000D29  1  A1 00        		lda	(0,x)
000D2B  1  95 01        		sta	1,x        ; store high-byte of term value
000D2D  1  68           		pla
000D2E  1               getval5:
000D2E  1  95 00        		sta	0,x        ; store low-byte of term value
000D30  1               getrts:
000D30  1  60           		rts
000D31  1               ;-----------------------------------------------------;
000D31  1               ; Set var[x] to the address of the variable named in a
000D31  1               ; entry:   a holds variable name, @[y] -> text holding
000D31  1               ;            array index expression (if a = ':')
000D31  1               ; uses:    plus, eval, oper8d, {@ &}
000D31  1               ; exit:    (eq): var[x] -> variable, @[y] unchanged
000D31  1               ;          (ne): var[x] -> array element,
000D31  1               ;                @[y] -> following text
000D31  1               ; 26 bytes
000D31  1               convp:
000D31  1  C9 3A        		cmp	#':'       ; array element?
000D33  1  D0 11        		bne	simple     ;   no: var[x] -> simple variable
000D35  1  20 C5 0C     		jsr	eval       ;   yes: evaluate array index at
000D38  1  16 00        		asl	0,x        ;     @[y] and advance y
000D3A  1  36 01        		rol	1,x
000D3C  1  A5 8C        		lda	ampr       ;     var[x] -> array element
000D3E  1  95 02        		sta	2,x        ;       at address 2*index+&
000D40  1  A5 8D        		lda	ampr+1
000D42  1  95 03        		sta	3,x
000D44  1  D0 39        		bne	plus       ;     (always taken)
000D46  1               ; The following section is designed to translate the
000D46  1               ;   named simple variable from its ASCII value to its
000D46  1               ;   zero-page address.  In this case, 'A' translates
000D46  1               ;   to $82, '!' translates to $c2, etc.  The method
000D46  1               ;   employed must correspond to the zero-page equates
000D46  1               ;   above, or strange and not-so-wonderful bugs will
000D46  1               ;   befall the weary traveller on his or her porting
000D46  1               ;   journey.
000D46  1               simple:
000D46  1               ;		sec
000D46  1               ;		sbc	#' '
000D46  1  C9 61        		cmp	#'a'
000D48  1  90 06        		bcc	simple1
000D4A  1  C9 7B        		cmp	#'z'+1
000D4C  1  B0 02        		bcs	simple1
000D4E  1  E9 1F        		sbc	#31
000D50  1               simple1:
000D50  1  49 20        		eor	#%00100000
000D52  1  0A           		asl	a          ; form simple variable address
000D53  1  09 80        		ora	#$80       ; mapping function is (a*2)|128
000D55  1  30 72        		bmi	oper8d     ; (always taken)
000D57  1               ;-----------------------------------------------------;
000D57  1               ; 16-bit unsigned multiply routine: var[x] *= var[x+2]
000D57  1               ; exit:    overflow is ignored/discarded, var[x+2] and
000D57  1               ;          {>} are modified, a = 0
000D57  1               ; 40 bytes
000D57  1               mul:
000D57  1  B5 00        		lda	0,x
000D59  1  85 BC        		sta	gthan
000D5B  1  B5 01        		lda	1,x        ; {>} = var[x]
000D5D  1  85 BD        		sta	gthan+1
000D5F  1  A9 00        		lda	#0
000D61  1  95 00        		sta	0,x        ; var[x] = 0
000D63  1  95 01        		sta	1,x
000D65  1               mul2:
000D65  1  A5 BC        		lda	gthan
000D67  1  05 BD        		ora	gthan+1
000D69  1  F0 13        		beq	mulrts     ; exit early if {>} = 0
000D6B  1  46 BD        		lsr	gthan+1
000D6D  1  66 BC        		ror	gthan      ; {>} /= 2
000D6F  1  90 03        		bcc	mul3
000D71  1  20 7F 0D     		jsr	plus       ; form the product in var[x]
000D74  1               mul3:
000D74  1  16 02        		asl	2,x
000D76  1  36 03        		rol	3,x        ; left-shift var[x+2]
000D78  1  B5 02        		lda	2,x
000D7A  1  15 03        		ora	3,x        ; loop until var[x+2] = 0
000D7C  1  D0 E7        		bne	mul2
000D7E  1               mulrts:
000D7E  1  60           		rts
000D7F  1               ;-----------------------------------------------------;
000D7F  1               ; var[x] += var[x+2]
000D7F  1               ; 14 bytes
000D7F  1               plus:
000D7F  1  18           		clc
000D80  1  B5 00        		lda	0,x
000D82  1  75 02        		adc	2,x
000D84  1  95 00        		sta	0,x
000D86  1  B5 01        		lda	1,x
000D88  1  75 03        		adc	3,x
000D8A  1  95 01        		sta	1,x
000D8C  1  60           		rts
000D8D  1               ;-----------------------------------------------------;
000D8D  1               ; Apply the binary operator in a to var[x] and var[x+2]
000D8D  1               ; Valid VTL02C operators are {* + / [ ] - | ^ & < = >}
000D8D  1               ; {>} is defined as greater than _or_equal_
000D8D  1               ; An undefined operator will be interpreted as one of
000D8D  1               ;   the three comparison operators
000D8D  1               ; 37 bytes
000D8D  1               oper:
000D8D  1  C9 2B        		cmp	#'+'       ; addition operator?
000D8F  1  F0 EE        		beq	plus
000D91  1  C9 2A        		cmp	#'*'       ; multiplication operator?
000D93  1  F0 C2        		beq	mul
000D95  1  C9 2F        		cmp	#'/'       ; division operator?
000D97  1  F0 77        		beq	div
000D99  1  C9 5B        		cmp	#'['       ; "then" operator?
000D9B  1  F0 32        		beq	then_
000D9D  1  C9 5D        		cmp	#']'       ; "else" operator?
000D9F  1  F0 3C        		beq	else_
000DA1  1  CA           		dex	           ; (factored from the following ops)
000DA2  1  C9 2D        		cmp	#'-'       ; subtraction operator?
000DA4  1  F0 41        		beq	minus
000DA6  1  C9 7C        		cmp	#OP_OR     ; bit-wise or operator?
000DA8  1  F0 52        		beq	or_
000DAA  1  C9 5E        		cmp	#'^'       ; bit-wise xor operator?
000DAC  1  F0 58        		beq	xor_
000DAE  1  C9 26        		cmp	#'&'       ; bit-wise and operator?
000DB0  1  F0 40        		beq	and_
000DB2  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000DB2  1               ; Apply comparison operator in a to var[x] and var[x+2]
000DB2  1               ;   and place result in var[x] (1: true, 0: false)
000DB2  1               ; expects:  (cs), pre-decremented x
000DB2  1               ; 29 bytes
000DB2  1  49 3C        		eor	#'<'       ; 0: '<'  1: '='  2: '>'
000DB4  1  85 BC        		sta	gthan      ; other values in a are undefined,
000DB6  1  20 E7 0D     		jsr	minus      ;   but _will_ produce some result
000DB9  1  C6 BC        		dec	gthan      ; var[x] -= var[x+2]
000DBB  1  D0 05        		bne	oper8b     ; equality test?
000DBD  1  15 00        		ora	0,x        ;   yes: 'or' high and low bytes
000DBF  1  F0 04        		beq	oper8c     ;     (cs) if 0
000DC1  1  18           		clc             ;     (cc) if not 0
000DC2  1               oper8b:
000DC2  1  A5 BC        		lda	gthan
000DC4  1  2A           		rol	a
000DC5  1               oper8c:
000DC5  1  69 00        		adc	#0
000DC7  1  29 01        		and	#1         ; var[x] = 1 (true), 0 (false)
000DC9  1               oper8d:
000DC9  1  95 00        		sta	0,x
000DCB  1  A9 00        		lda	#0
000DCD  1  F0 20        		beq	minus3     ; (always taken)
000DCF  1               ;-----------------------------------------------------;
000DCF  1               ; expects:  (cs)
000DCF  1               ; 14 bytes
000DCF  1               then_:
000DCF  1  B5 00        		lda	0,x
000DD1  1  15 01        		ora	1,x
000DD3  1  F0 1C        		beq	minus4
000DD5  1  B5 02        		lda	2,x
000DD7  1  95 00        		sta	0,x
000DD9  1  B5 03        		lda	3,x
000DDB  1  B0 12        		bcs	minus3     ; (always taken)
000DDD  1               ;-----------------------------------------------------;
000DDD  1               ; expects:  (cs)
000DDD  1               ; 10 bytes
000DDD  1               else_:
000DDD  1  B5 00        		lda	0,x
000DDF  1  15 01        		ora	1,x
000DE1  1  F0 9C        		beq	plus
000DE3  1  A9 00        		lda	#0
000DE5  1  F0 E2        		beq	oper8d     ; (always taken)
000DE7  1               ;-----------------------------------------------------;
000DE7  1               ; var[x] -= var[x+2]
000DE7  1               ; expects:  (cs), pre-decremented x
000DE7  1               ; 11 bytes
000DE7  1               minus:
000DE7  1  20 EB 0D     		jsr	minus2
000DEA  1  E8           		inx
000DEB  1               minus2:
000DEB  1  B5 01        		lda	1,x
000DED  1  F5 03        		sbc	3,x
000DEF  1               minus3:
000DEF  1  95 01        		sta	1,x
000DF1  1               minus4:
000DF1  1  60           		rts
000DF2  1               ;-----------------------------------------------------;
000DF2  1               ; var[x] &= var[x+2]
000DF2  1               ; expects:  (cs), pre-decremented x
000DF2  1               ; 10 bytes
000DF2  1               and_:
000DF2  1  20 F6 0D     		jsr	and_2
000DF5  1  E8           		inx
000DF6  1               and_2:
000DF6  1  B5 01        		lda	1,x
000DF8  1  35 03        		and	3,x
000DFA  1  B0 F3        		bcs	minus3     ; (always taken)
000DFC  1               ;-----------------------------------------------------;
000DFC  1               ; var[x] |= var[x+2]
000DFC  1               ; expects:  (cs), pre-decremented x
000DFC  1               ; 10 bytes
000DFC  1               or_:
000DFC  1  20 00 0E     		jsr	or_2
000DFF  1  E8           		inx
000E00  1               or_2:
000E00  1  B5 01        		lda	1,x
000E02  1  15 03        		ora	3,x
000E04  1  B0 E9        		bcs	minus3     ; (always taken)
000E06  1               ;-----------------------------------------------------;
000E06  1               ; var[x] ^= var[x+2]
000E06  1               ; expects:  (cs), pre-decremented x
000E06  1               ; 10 bytes
000E06  1               xor_:
000E06  1  20 0A 0E     		jsr	xor_2
000E09  1  E8           		inx
000E0A  1               xor_2:
000E0A  1  B5 01        		lda	1,x
000E0C  1  55 03        		eor	3,x
000E0E  1  B0 DF        		bcs	minus3     ; (always taken)
000E10  1               ;-----------------------------------------------------;
000E10  1               ; 16-bit unsigned division routine
000E10  1               ;   var[x] /= var[x+2], {%} = remainder, {>} modified
000E10  1               ;   var[x] /= 0 produces {%} = var[x], var[x] = 65535
000E10  1               ; 43 bytes
000E10  1               div:
000E10  1  A9 00        		lda	#0
000E12  1  85 8A        		sta	remn       ; {%} = 0
000E14  1  85 8B        		sta	remn+1
000E16  1  A9 10        		lda	#16
000E18  1  85 BC        		sta	gthan      ; {>} = loop counter
000E1A  1               div1:
000E1A  1  16 00        		asl	0,x        ; var[x] is gradually replaced
000E1C  1  36 01        		rol	1,x        ;   with the quotient
000E1E  1  26 8A        		rol	remn       ; {%} is gradually replaced
000E20  1  26 8B        		rol	remn+1     ;   with the remainder
000E22  1  A5 8A        		lda	remn
000E24  1  D5 02        		cmp	2,x
000E26  1  A5 8B        		lda	remn+1     ; partial remainder >= var[x+2]?
000E28  1  F5 03        		sbc	3,x
000E2A  1  90 0A        		bcc	div2
000E2C  1  85 8B        		sta	remn+1     ;   yes: update the partial
000E2E  1  A5 8A        		lda	remn       ;     remainder and set the
000E30  1  F5 02        		sbc	2,x        ;     low bit in the partial
000E32  1  85 8A        		sta	remn       ;     quotient
000E34  1  F6 00        		inc	0,x
000E36  1               div2:
000E36  1  C6 BC        		dec	gthan
000E38  1  D0 E0        		bne	div1       ; loop 16 times
000E3A  1  60           		rts
000E3B  1               ;-----------------------------------------------------;
000E3B  1               ; If text at @[y] is a decimal constant, translate it
000E3B  1               ;   into var[x] (discarding any overflow) and update y
000E3B  1               ; entry:   @[y] -> text containing possible constant;
000E3B  1               ;            leading space characters are skipped, but
000E3B  1               ;            any spaces encountered after a conversion
000E3B  1               ;            has begun will end the conversion.
000E3B  1               ; used by: user:, getval:
000E3B  1               ; uses:    mul:, plus:, var[x], var[x+2], {@ > ?}
000E3B  1               ; exit:    (ne): var[x] = constant, @[y] -> next text
000E3B  1               ;          (eq): var[x] = 0, @[y] unchanged
000E3B  1               ;          (cs): in all but the truly strangest cases
000E3B  1               ; 43 bytes
000E3B  1               cvbin:
000E3B  1               ;		lda	#0
000E3B  1  74 00        		stz	0,x        ; var[x] = 0
000E3D  1  74 01        		stz	1,x
000E3F  1  74 03        		stz	3,x
000E41  1               
000E41  1  20 DB 0E     		jsr	getbytevtl    ; skip any leading spaces
000E44  1  84 BE        		sty	ques       ; save pointer
000E46  1               cvbin2:
000E46  1  B1 C0        		lda	(at),y     ; grab a char
000E48  1  49 30        		eor	#'0'       ; if char at @[y] is not a
000E4A  1  C9 0A        		cmp	#10        ;   decimal digit then stop
000E4C  1  B0 13        		bcs	cvbin3     ;   the conversion
000E4E  1  48           		pha	           ; save decimal digit
000E4F  1  A9 0A        		lda	#10
000E51  1  95 02        		sta	2,x
000E53  1  20 57 0D     		jsr	mul        ; var[x] *= 10
000E56  1  95 03        		sta	3,x
000E58  1  68           		pla	           ; retrieve decimal digit
000E59  1  95 02        		sta	2,x
000E5B  1  20 7F 0D     		jsr	plus       ; var[x] += digit
000E5E  1  C8           		iny	           ; loop for more digits
000E5F  1  10 E5        		bpl	cvbin2     ;   (with safety escape)
000E61  1               cvbin3:
000E61  1  C4 BE        		cpy	ques       ; (ne) if valid, (eq) if not
000E63  1  60           		rts
000E64  1               ;-----------------------------------------------------;
000E64  1               ; Accept input line from user and store it in linbuf,
000E64  1               ;   zero-terminated (allows very primitive edit/cancel)
000E64  1               ; entry:   (jsr to inln or newln, not inln6)
000E64  1               ; used by: user:, getval:
000E64  1               ; uses:    inch:, outnl:, linbuf, {@}
000E64  1               ; exit:    @[y] -> linbuf
000E64  1               ; 42 bytes
000E64  1               
000E64  1               ;inln6:
000E64  1               ;		cmp	#ESC       ; escape?
000E64  1               ;		beq	newln      ;   yes: discard entire line
000E64  1               ;		iny	           ; line limit exceeded?
000E64  1               ;		bpl	inln2      ;   no: keep going
000E64  1               ;newln:
000E64  1               ;		jsr	outnl      ;   yes: discard entire line
000E64  1               ;inln:
000E64  1               ;		ldy	#<(linbuf) ; entry point: start a fresh line
000E64  1               ;		sty	at         ; {@} -> input line buffer
000E64  1               ;		ldy	#>(linbuf)
000E64  1               ;		sty	at+1
000E64  1               ;		ldy	#1
000E64  1               ;inln5:
000E64  1               ;		dey
000E64  1               ;		bmi	newln
000E64  1               ;inln2:
000E64  1               ;		jsr	inch       ; get (and echo) one key press
000E64  1               ;		cmp	#BS        ; backspace?
000E64  1               ;		beq	inln5      ;   yes: delete previous char
000E64  1               ;		cmp	#EOL       ; cr?
000E64  1               ;		bne	inln3
000E64  1               ;		lda	#0         ;   yes: replace with null
000E64  1               ;inln3:
000E64  1               ;		sta	(at),y     ; put key in linbuf
000E64  1               ;		bne	inln6      ; continue if not null
000E64  1               ;		tay            	   ; y = 0
000E64  1               ;		rts
000E64  1               
000E64  1               
000E64  1               inln:
000E64  1  A2 00        		ldx	#0
000E66  1  A9 05        		lda	#GETREC
000E68  1  9D 82 02     		sta	ICCOM,x
000E6B  1  8A           		txa
000E6C  1  9D 88 02     		sta	ICBLH,x
000E6F  1  A9 50        		lda	#80
000E71  1  9D 87 02     		sta	ICBLL,x
000E74  1  A9 80        		lda	#<FNAME
000E76  1  9D 84 02     		sta	ICBAL,x
000E79  1  85 C0        		sta	at
000E7B  1  A9 03        		lda	#>FNAME
000E7D  1  9D 85 02     		sta	ICBAH,x
000E80  1  85 C1        		sta	at+1
000E82  1  20 0F C0     		jsr	CIOV
000E85  1  8A           		txa
000E86  1  A8           		tay
000E87  1  AE 87 02     		ldx	ICBLL
000E8A  1  9D 7F 03     		sta	FNAME-1,x
000E8D  1               inln1:
000E8D  1  CA           		dex
000E8E  1  BD 7F 03     		lda	FNAME-1,x
000E91  1  C9 20        		cmp	#' '
000E93  1  D0 06        		bne	inlnex
000E95  1  98           		tya
000E96  1  9D 7F 03     		sta	FNAME-1,x
000E99  1  F0 F2        		beq	inln1
000E9B  1               inlnex:
000E9B  1  60           		rts
000E9C  1               
000E9C  1               ;-----------------------------------------------------;
000E9C  1               ; Find the first/next stored program line >= {#}
000E9C  1               ; entry:   (cc): start search at program beginning
000E9C  1               ;          (cs): start search at next line
000E9C  1               ;          ({@} -> beginning of current line)
000E9C  1               ; used by: skp2:, findln:
000E9C  1               ; uses:    prgm, {@ # & (}
000E9C  1               ; exit:    (cs): {@}, x:a and {(} undefined, y = 2
000E9C  1               ;          (cc): {@} -> beginning of found line, y = 2,
000E9C  1               ;                x:a = {(} = actual found line number
000E9C  1               ; 62 bytes
000E9C  1               find:
000E9C  1  A2 10        		ldx	#>(prgm)
000E9E  1  A9 00        		lda	#<(prgm)
000EA0  1  90 15        		bcc	find1st    ; cc: search begins at first line
000EA2  1  A6 C1        		ldx	at+1
000EA4  1  A0 02        		ldy	#2
000EA6  1               findnxt:
000EA6  1  A5 C0        		lda	at
000EA8  1  C5 8C        		cmp	ampr
000EAA  1  A5 C1        		lda	at+1
000EAC  1  E5 8D        		sbc	ampr+1     ; {@} >= {&} (end of program)?
000EAE  1  B0 29        		bcs	findrts    ;   yes: search failed (cs)
000EB0  1               find3:
000EB0  1  A5 C0        		lda	at
000EB2  1  71 C0        		adc	(at),y     ;   no: {@} -> next line
000EB4  1  90 03        		bcc	find5
000EB6  1  E8           		inx
000EB7  1               find1st:
000EB7  1  86 C1        		stx	at+1
000EB9  1               find5:
000EB9  1  85 C0        		sta	at
000EBB  1  A0 00        		ldy	#0
000EBD  1  B1 C0        		lda	(at),y
000EBF  1  85 90        		sta	lparen     ; {(} = current line number
000EC1  1  C5 86        		cmp	pound      ;   (invalid if {@} >= {&}, but
000EC3  1  C8           		iny	           ;   we'll catch that later...)
000EC4  1  B1 C0        		lda	(at),y
000EC6  1  85 91        		sta	lparen+1
000EC8  1  E5 87        		sbc	pound+1    ; if {(} < {#} then try the next
000ECA  1  C8           		iny	           ;   program line
000ECB  1  90 D9        		bcc	findnxt
000ECD  1  A5 C0        		lda	at         ; {@} >= {&} (end of program)?
000ECF  1  C5 8C        		cmp	ampr       ;   yes: search failed (cs)
000ED1  1  A5 C1        		lda	at+1       ;   no: search succeeded (cc)
000ED3  1  E5 8D        		sbc	ampr+1
000ED5  1  A5 90        		lda	lparen
000ED7  1  A6 91        		ldx	lparen+1
000ED9  1               findrts:
000ED9  1  60           		rts
000EDA  1               ;-----------------------------------------------------;
000EDA  1               ; Fetch a byte at @[y], ignoring space characters
000EDA  1               ; 10 bytes
000EDA  1               skpbyte:
000EDA  1  C8           		iny             ; skip over current char
000EDB  1               getbytevtl:
000EDB  1  B1 C0        		lda	(at),y
000EDD  1  F0 04        		beq	getbyt2
000EDF  1  C9 20        		cmp	#' '
000EE1  1  F0 F7        		beq	skpbyte    ; skip over any space char(s)
000EE3  1               getbyt2:
000EE3  1  60           		rts
000EE4  1               
000EE4  1               ;============ Original I/O subroutines ===============;
000EE4  1               ;-----------------------------------------------------;
000EE4  1               ; Check for user keypress and return with (cc) if none
000EE4  1               ;   is pending.  Otherwise, fall through to inch
000EE4  1               ;   and return with (cs).
000EE4  1               ; 6 bytes
000EE4  1               ;inkey:
000EE4  1               ;    lda  KBD        ; is there a keypress waiting?
000EE4  1               ;    asl
000EE4  1               ;    bcc  outrts     ;   no: return with (cc)
000EE4  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000EE4  1               ; Read key from stdin into a, echo, (cs)
000EE4  1               ; drop stack and abort to "OK" prompt if ctrl-C
000EE4  1               ; 16 bytes
000EE4  1               ;inch:
000EE4  1               ;    sty  dolr       ; save y reg
000EE4  1               ;    jsr  KEYIN      ; get a char from keyboard
000EE4  1               ;    ldy  dolr       ; restore y reg
000EE4  1               ;    and  #$7f       ; strip apple's hi-bit
000EE4  1               ;    cmp  #$03       ; ctrl-C?
000EE4  1               ;    bne  outch      ;   no: echo to terminal
000EE4  1               ;    jmp  start      ;   yes: abort to "OK" prompt
000EE4  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000EE4  1               ; Print ASCII char in a to stdout, (cs)
000EE4  1               ; 9 bytes
000EE4  1               ;outch:
000EE4  1               ;    pha             ; save original char
000EE4  1               ;    ora  #$80       ; apples prefer "high" ASCII
000EE4  1               ;    jsr  COUT       ; emit char via apple monitor
000EE4  1               ;    pla             ; restore original char
000EE4  1               ;    sec             ; (by contract with callers)
000EE4  1               ;outrts:
000EE4  1               ;    rts
000EE4  1               ;-----------------------------------------------------;
000EE4  1               ;========== 2m5 SBC emulator I/O subroutines ============;
000EE4  1               ;-----------------------------------------------------;
000EE4  1               ; Check for user keypress and return if none
000EE4  1               ;   is pending.  Otherwise, check for ctrl-C and
000EE4  1               ;   return after next keypress.
000EE4  1               ;
000EE4  1               inkey:
000EE4  1  18           		clc
000EE5  1  AD 2D 03     		lda	IRQPS2S    ; Is there a character waiting?
000EE8  1  D0 08        		bne	inkeyr     ;   no: return
000EEA  1               
000EEA  1  20 03 E0     		jsr	jchrin
000EED  1  C9 03        		cmp	#3         ; is ctrl-c
000EEF  1  F0 07        		beq	istart     ;   yes: abort to OK prompt
000EF1  1               ;inkeyp:
000EF1  1               ;		lda	IRQPS2S    ; pause until next key
000EF1  1               ;		bne	inkeyp
000EF1  1               ;		jsr	jchrin
000EF1  1               
000EF1  1               ;		cmp	#3         ; is ctrl-c
000EF1  1               ;		beq	istart     ;   yes: abort to OK prompt
000EF1  1  38           		sec
000EF2  1               inkeyr:
000EF2  1  60           		rts
000EF3  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000EF3  1               ; Read key from stdin into a, echo, (cs)
000EF3  1               ; Dump stack and abort to "OK" prompt if ctrl-C
000EF3  1               ;
000EF3  1               inch:
000EF3  1               ;		lda	IRQPS2S    ; get character from rx register
000EF3  1               ;		bne	inch       ; wait for character !=0
000EF3  1  20 03 E0     		jsr	jchrin
000EF6  1  38           		sec
000EF7  1  60           		rts
000EF8  1               
000EF8  1               ;		sty	dolr       ; save y reg
000EF8  1               ;		cmp	#127       ; convert delete to backspace
000EF8  1               ;		bne	conv_bs2del
000EF8  1               ;		lda	#8
000EF8  1               ;conv_bs2del:
000EF8  1               ;		cmp	#27        ; escape?
000EF8  1               ;		bne	skip_esc_no
000EF8  1               ;		ldy	#5         ; timer loop - 5*10ms
000EF8  1               ;skip_esc_next:
000EF8  1               ;;		lda	#1         ; ack last tick
000EF8  1               ;;		sta	acia_st
000EF8  1               ;skip_esc_wait:
000EF8  1               ;;		lda	acia_st
000EF8  1               ;;		and	#1         ; next tick
000EF8  1               ;;		beq	skip_esc_wait
000EF8  1               ;		dey
000EF8  1               ;		bne	skip_esc_next
000EF8  1               ;skip_esc_discard:
000EF8  1               ;		iny             ; any data = y > 1
000EF8  1               ;		lda	IRQPS2S
000EF8  1               ;		bne	skip_esc_discard
000EF8  1               ;		cpy	#1
000EF8  1               ;		bne	inch
000EF8  1               ;skip_esc_esc:       			; escape only - send to vtl
000EF8  1               ;		lda	#27
000EF8  1               ;		rts
000EF8  1               ;skip_esc_no:
000EF8  1               ;		ldy	dolr       ; restore y reg
000EF8  1               ;inch2:
000EF8  1               ;		and	#$7f       ; ensure char is positive ascii
000EF8  1               ;		cmp	#$03       ; ctrl-C?
000EF8  1               ;		bne	outch      ;   no: echo to terminal
000EF8  1               istart:
000EF8  1  4C 17 0A     		jmp	start      ;   yes: abort to "OK" prompt
000EFB  1               ; - - - - - - - - - - - - - - - - - - - - - - - - - - ;
000EFB  1               ; Print ascii char in a to stdout, (cs)
000EFB  1               ;
000EFB  1               outch:
000EFB  1               ;		cmp	#13        ; add line feed to carriage return
000EFB  1               ;		bne	skip_cr
000EFB  1               ;		lda	#10
000EFB  1               ;		sta	acia_tx
000EFB  1               ;		jsr	jchrout
000EFB  1               ;		lda	#13
000EFB  1               skip_cr:
000EFB  1               ;		cmp	#8         ; backspace?
000EFB  1               ;		bne	skip_bs;
000EFB  1               ;		sta	acia_tx    ; make erasing backspace
000EFB  1               ;		jsr	jchrout
000EFB  1               ;		lda	#' '
000EFB  1               ;		sta	acia_tx
000EFB  1               ;		jsr	jchrout
000EFB  1               ;		lda	#8
000EFB  1               skip_bs:
000EFB  1  20 06 E0     		jsr	jchrout
000EFE  1               ;		sta	acia_tx    ; emit char via transmit register
000EFE  1  38           		sec          	   ; (by contract with callers)
000EFF  1  60           		rts
000F00  1               ;-----------------------------------------------------;
000F00  1               ;   org  $fffc
000F00  1               ;    dw   vtl02c     ; reset vector -> cold start
000F00  1               ;   end  vtl02c     ; set start address
000F00  1               
